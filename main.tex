\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{thmtools}
\usepackage{stmaryrd}

\usepackage{tikz}
\usetikzlibrary{arrows.meta,automata,positioning,calc,trees}
\usepackage{tikz-cd}
\usepackage{graphicx}

\usepackage{caption}

\usepackage{hyperref}

\usepackage{color}
\usepackage{xcolor}

\usepackage[hyperref]{knowledge}
\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}

\input{macros}
\input{tre-uniformisation.kl}


\title{Decidability of MSO Uniformisation on Finite Trees}

\author{Thomas Colcombet}
	{CNRS, IRIF, Universit\'e Paris Diderot, France}
	{thomas.colcombet@irif.fr}
	{https://orcid.org/0000-0001-6529-6963}
	{}

\author{Yago Iglesias Vázquez}{Universit\'e Paris Diderot, France}{me@yagoiglesias.fr}{}{}
\nolinenumbers


\authorrunning{T. Colcombet, Y. Iglesias Vázquez} 

\Copyright{Thomas Colcombet, Yago Iglesias Vázquez} 

\ccsdesc[500]{Theory of computation~Finite Model Theory}
\ccsdesc[500]{Theory of computation~Algebraic language theory}
\ccsdesc[500]{Theory of computation~Regular languages}

\keywords{MSO, uniformization, finite state automata, trees} 

\category{Rapport de stage} 

\relatedversion{} 

\begin{document}

\maketitle

\begin{abstract}
	We study "uniformisation" for "MSO" formulas over finite binary "trees". A formula $\psi(X)$ "uniformises" $\phi(X)$
	if it selects at most one witness $X$ and, whenever $\phi$ has a witness, $\psi$ picks one. We show that,
	using symmetry-preserving automata ("order-insensitive" automata), it is decidable whether a
	given $\phi$ admits such a "uniformiser", and in the positive case, we effectively construct $\psi$. Our procedure translates $\phi$ into
	an "order-insensitive" "deterministic bottom-up tree automaton", checks whether that "automaton@DBUA" "accepts" every "tree", and, when
	it does, extracts from its "transition relation" an "MSO" formula that uniformly selects a witness. This reduces "MSO" "uniformisation"
	on finite "trees" to a simple "automata universality" test and a formula extraction step.
\end{abstract}

\tableofcontents
\todo{remove table of contents}
\todo{change knowledge mode}
\todo{an vs a}
\todo{verify that the AP are all there}
\newpage
\section{Introduction}

"Monadic second‐order" ("MSO") logic is a well-studied fragment of second-order logic with wide-ranging applications in graph theory, automata theory, and formal verification.
In particular, its deep connection with automata theory has been extensively explored. It is well known that MSO over finite words is equivalent in expressive power to
finite-state automata~\cite{Buchi60}.

This correspondence extends beyond words: automata can also be defined to run on "trees". Over finite "trees", MSO logic remains equivalent in expressive power to finite-state
tree automata~\cite{TW68, Don70}. This connection enables the use of automata-theoretic techniques to reason about "trees", one of the most fundamental and widely studied data
structures.

A classical challenge in this context is the \emph{uniformisation problem}: given an MSO formula $\phi(X)$ that asserts the existence of a set $X$ satisfying a certain property,
is it possible to define another MSO formula $\psi(Y)$ that selects \emph{at most one} such set for each tree, in a way that agrees with $\phi$ whenever it is satisfiable? We
formalize this notion in \Cref{sec:uniformisation}.

This problem has been studied in various settings. A comprehensive survey is provided in~\cite{Cara15}. Positive results are known for infinite words, where every MSO-definable
relation admits an MSO-definable uniformising function~\cite{Siefkes1975, Choffrut1999, Rabin07}. In contrast, uniformisation is not possible in general for infinite binary
trees~\cite{GS83}.
In this work, we study MSO uniformisation over a different class of structures: \emph{finite, labeled binary trees}.
All of the technical work is performed using only automata that preserve structural symmetry,
\ie they are unable to distinguish between left and right "subtrees".

The central question addressed in this paper is:

\begin{problem}[The ""uniformisation"" problem]\label{prob:uniformisation-problem}
\AP Given an MSO formula $\phi(X)$, does there exist a "uniformiser" $\psi(X)$?
\end{problem}
\todo{state the theorem / ref it}

Our main result is that this question is \emph{decidable}, and in the positive case, a "uniformiser" $\psi$ can be effectively constructed. Concretely, we translate $\phi$ into a
"deterministic bottom-up tree automaton" whose "transition map" is "order-insensitive" (\ie closed under sibling swaps). We then perform a "universality" check on this
automaton—does it accept every tree?—and, when it does, we extract from its transitions an MSO formula that uniformly selects a witness.

\todo{better formulate this}
This paper makes three main contributions:
\begin{itemize}
	\item Extending the decidability of MSO "uniformisation" to finite binary "trees" using only symmetry preserving automata,
	\item Providing a constructive method to extract a "uniformiser" via "automata universality", and
	\item Demonstrating how to handle sibling‐permutation symmetry in "tree" transformations.
\end{itemize}


\paragraph*{Structure of the paper.} The remainder of the paper is structured as follows:
\Cref{sec:definitions} introduces the necessary definitions, notations and classical results on "trees", "automata@DBUA", and "MSO logic", with an emphasis on the "order-insensitive"
variant of tree automata.
In \Cref{sec:uniformisation}, we define the uniformisation problem and present our main result, showing that it is decidable for finite binary trees.
We conclude in \Cref{sec:conclusion} with a discussion of the implications of our results and potential future work.

\section{Definitions} \label{sec:definitions}

In this section, we review classical concepts related to trees, automata, and logic.
\Cref{sec:trees} establishes our notation for trees.
\Cref{sec:automata} provides a brief overview of bottom-up tree automata.
\Cref{sec:OrderAutomata} introduces an order-insensitive variant of these automata, and
\Cref{sec:UniversalityAutomata} defines a corresponding universality test.
Finally, \Cref{sec:MSO} describes how to translate MSO formulas into automata while preserving order insensitivity.

\subsection{Trees}\label{sec:trees}

This first subsection contains the definition of the "trees" we are working with. Other equivalent definitions of "trees" and
automata are possible~\cite{Thomas1997, tata}, but we have chosen this one because it is more intuitive, without adding much complexity to the proofs.

\begin{definition}["Tree"]
	\AP A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$;
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are "trees".
	\end{itemize}
	We call the ""root"" of a "tree" the first node in its definition.
	The set of all "trees" over $\Sigma$ is denoted $\intro* \tree_{\Sigma}$.
\end{definition}

\begin{figure}[h]
	\centering

	\begin{tikzpicture}[
			level distance=1cm,
			sibling distance=1.5cm,
			every node/.style = {draw, circle}
		]

		\node {a}
		child { node {b} }
		child { node {c}
				child { node {d} }
				child { node {e} }
			};

	\end{tikzpicture}

	\caption{Concrete tree corresponding to $a(b, c(d, e))$.}
\end{figure}

\AP This recursive structure induces a natural notion of position within a "tree". We now define the set of ""nodes"",
represented as words over $\{0,1\}$ indicating a path from the root as
\[
	\intro* \Nodes t =
	\begin{cases}
		\varepsilon                             & \text{if } t = a         \\
		\varepsilon \cup \setdef {0u} {u \in \Nodes {t'}}
		\cup \setdef {1u} {u \in \Nodes {t''} } & \text{if } t = a(t',t'')
	\end{cases}
\]

\begin{example}
	Let $ t := a(b, c(d, e)) $. We compute:
	\[
		\Nodes b  = \{\varepsilon\}, \quad \Nodes {c(d, e)} = \{\varepsilon, 0, 1\}
	\]
	\[
		\Nodes t = \{\varepsilon\} \cup \{0\} \cup \{1, 10, 11\} = \{\varepsilon, 0, 1, 10, 11\}
	\]
\end{example}

Among the "nodes", some are distinguished as "leaves", "nodes" without children.
\AP The ""leaves"" of a "tree" $t$ are defined as follows:
\[
	\intro* \Leaves t = \begin{cases}
		\varepsilon                              & \text{if } t = a         \\
		\setdef {0u} {u \in \Leaves {t'}}
		\cup \setdef {1u} {u \in \Leaves {t''} } & \text{if } t = a(t',t'')
	\end{cases}
\]

\AP We can see that $\Leaves t \subseteq \Nodes t$ and we call ""internal nodes"" the set $\Nodes t \cap \Leaves t$


Each "node" in a "tree" carries a symbol from the alphabet.
\AP Given a "tree" $t$ and a "node"$n$, we can access the ""label"" of the "node" $n$
thanks to the function $\intro* \tlabel t {\cdot}$ :
\[
	\tlabel t n =   \begin{cases}
		a               & \text{if } t = a \text{ and } n = \varepsilon         \\
		a               & \text{if } t = a(t',t'') \text{ and } n = \varepsilon \\
		\tlabel {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m          \\
		\tlabel {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
	\end{cases}
\]

We often need to refer to the "subtree" rooted at a particular "node".
\AP We introduce the notation $\intro* \subtree t n$ to refer to the "subtrees"
of $t$ rooted at the node $n$. This can be computed as follows:
\[
	\subtree t n =   \begin{cases}
		t                & \text{if }  n = \varepsilon                  \\
		\subtree {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m \\
		\subtree {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
	\end{cases}
\]

The "ancestor" relation captures the natural hierarchical structure of a "tree": a "node" $x$ is an "ancestor"
of a "node" $y$ if $y$ is located in the "subtree" rooted at $x$.

\begin{definition}
	\AP Let $t$ be a "tree" and $x, y \in \Nodes t$. We define the ""ancestor"" relation as:
	\[
		x \intro* \ancestor y \tiff \exists z \in \Nodes t,\, y = xz
	\]
\end{definition}

\begin{remark}
	Note that this order does not depend on the left or right position of the children, \ie it preserves
	"order-insensitivity", this will be explored in the following sections.
\end{remark}


\subsection{Automata over trees}\label{sec:automata}

In this subsection we aim to define the basics of tree automata in a comprehensive way, adding as much detail as possible to the proofs. For reference,
one can look at more advanced book on this topic \cite{tata,Thomas1997,bookautomata}.

In classical automata theory, we analyze deterministic finite automaton (DFA), wich assign a unique state to each prefix of
a word, updating this state at each step using a transition function, ussualy reading the input from left to right.

A "deterministic bottom-up tree automaton" ("DBUA") generalizes this idea to "trees": instead of reading a linear word, it reads a
a "tree" where each "node" carries a symbol from a fixed alphabet. Rather than scanning from left to right, it proceeds
bottom-up, computing "states" at each "node" by combining the states of its children :
the automaton aggregates the information from those "subtrees" to assign a "state" to the parent.

The idea is to recursively assign a "state" to each "node" of the "tree":
\begin{itemize}
	\item At the "leaves", the "state" is determined directly from the symbol via a function $\init$, just as a DFA starts in a particular initial state.
	\item A DFA transitions based on the current letter and the state reached by the previous letters.
	      When a "NBUA" reaches an "internal node", it transitions based on the "states" reached by its children and the "label" associated to the "node".
	\item Finally, the "state" assigned to the "root" tells us whether the whole "tree" is "accepted",
	      depending on whether it belongs to a set of "final states".
\end{itemize}

We now state the formal definitions.

\begin{definition}
	\AP A ""deterministic bottom-up tree automaton"" (\reintro*"DBUA") is a tuple $(\Sigma, Q, \init, \delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		      \itemAP $Q$ is a finite set of ""states"".
		      \itemAP $\intro *\init : \Sigma \to Q$ is a function that initializes the states of the "leaves".
		      \itemAP $\delta : Q \times Q \times \Sigma \to Q$ is the ""transition map"". \todo{make this a macro}
		      \itemAP $F \subseteq Q$ is the set of ""final states"".
	\end{itemize}
\end{definition}

\begin{definition}[Interpretation of an automaton]
	\AP The ""interpretation"" of a "DBUA" $A = (\Sigma, Q, \init, \delta, F)$  over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\intro* \interpret A ~: \tree_{\Sigma} &\to& Q \\
		a &\mapsto& \init_a \\
		a(t,t') &\mapsto& \delta_a (\interpret A t, \interpret A {t'})
	\end{eqnarray*}

	We say that $A$ ""accepts"" a "tree" $t$ if $\interpret A t \in F$.

	We will sometimes use the notation $\delta(t)$ for the "interpretation" of $A$ over the "tree" $t$.
\end{definition}

\begin{example}[Trees with at most one leaf]\label{ex:count-leaves}
	We define a "DBUA" $A = (\Sigma, Q, \init, \delta, F)$ that "accepts" exactly the "trees" with at most one "leaf". Let:
	\begin{itemize}
		\item $Q = \{0,1,2\}$, where $q=0$ means \textit{no leaves}, $q=1$ means \textit{exactly one leaf},
		      and $q=2$ means \textit{more than one leaf}.
		\item $F = \{0,1\}$.
		\item For all $a \in \Sigma$, we define $\init_a = 1$.
		\item The transition function is defined by:
		      \[
			      \delta_a(q_1, q_2) = \min(q_1 + q_2, 2)
		      \]
	\end{itemize}

	Intuitively, this automaton counts the number of "leaves" in the "tree", but caps the count at $2$ to detect when the number exceeds $1$.
	\Cref{fig:count-leaves} illustrates the execution of this automaton over a particular input.
\end{example}


\begin{figure}[h]\label{fig:count-leaves}
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			sibling distance=1.3cm,
			every node/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			treenode/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			scale=1, transform shape,
			state/.style={blue}
		]

		% TREE 1
		\node (t1) at (0,0) {a}
		child {node (t1b1) {b}}
		child {node (t1a2) {a}
				child {node (t1b3) {b}}
				child {node (t1b4) {b}}};

		\node at (2.2, -1) {$\Rightarrow$};

		% TREE 2
		\node (t2) at (4.5,0) {a}
		child {node[state ](t2b1) {1}}
		child {node (t2a2) {a}
				child {node[state] (t2s2) {1}}
				child {node[state] (t2s3) {1}}};

		\node at (6.7, -1) {$\Rightarrow$};

		% TREE 3 
		\node (t3) at (9,0) {a}
		child {node[state] (t3s4) {1}}
		child {node[state] (t3a2) {2}};

		\node at (11.2, -1) {$\Rightarrow$};

		% TREE 4 
		\node[state] (t4) at (13.5,0) {2};

	\end{tikzpicture}
	\caption{Execution of the automaton of \Cref{ex:count-leaves} over the input $a(b,a(b,b))$}
\end{figure}




In the same way that we can define a non-deterministic automaton over strings, the same can be done for
tree automata using the same techniques. We will define them and give basic definitions on how to use them.

\begin{definition}
	\AP A ""non-deterministic bottom-up tree automaton"" (\reintro* "NBUA") is defined as a tuple
	$(\Sigma, Q, I, \Delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of "states".
		\item $I \subseteq \Sigma \times Q$ correspond to the possible states of the "leaves".
		      \itemAP $\Delta \subseteq Q \times Q \times \Sigma \times Q$ is the ""transition relation"".
		\item $F \subseteq Q$ is the set of "final states".
	\end{itemize}
\end{definition}

\begin{definition}[Run of an automaton]
	\AP A ""run"" $\intro* \exec$ of a "NBUA" $A$ over a "tree" $t$ is :

	\begin{eqnarray*}
		\exec : \Nodes t &\to& Q \\
		(\tlabel t b,  \exec (n) ) \in I &\text{ if }& n \in \Leaves t \\
		(\exec (n0), \exec (n1), \tlabel t n, \exec (n)) \in \Delta &\text{ if }& n \in \Nodes t \setminus \Leaves t
	\end{eqnarray*}

	We say that $\exec$ is "acceptant" if $\exec (\varepsilon) \in F$ and $A$ "accepts" $t$ if
	$F \cap \setdef {\rho(\varepsilon)} {\text{$\rho$ "run" of~$A$ over~$t$}} \neq \emptyset$
\end{definition}


\begin{definition}[Language of an automaton]
	\AP Let $A$ be a "NBUA". Its ""associated language"" is defined as:
	\[\intro* \lang A = \setdef {t \in \tree_{\Sigma}} {\text{exists $\rho$ a "accepting" "run" of $A$ over $t$}} \]
\end{definition}

We can easily see that "DBUA" are a particular case of "NBUA", just like in the classic theory.

\begin{remark}
	Every "DBUA" $A = (\Sigma, Q, \init, \delta, F)$ can be seen as a special case of a "NBUA"
	$A' = (\Sigma, Q, I, \Delta, F)$ where:
	\begin{itemize}
		\item $I = \setdef{(a, \init_a)}{a \in \Sigma}$,
		\item $\Delta = \setdef{(q_1, q_2, a, \delta_a(q_1, q_2))}{q_1, q_2 \in Q, a \in \Sigma}$.
	\end{itemize}

	In this case, $A'$ has exactly one possible "run" on each "tree" :

	\begin{eqnarray*}
		\exec : \Nodes t &\to & Q \\
		n  &\mapsto& \init_{\tlabel t n} \text{ if } n \in \Leaves t \\
		n  &\mapsto& \delta_{\tlabel t n}(\exec (n0), \exec (n1)) \text{ if } n \in \Nodes t \setminus \Leaves t
	\end{eqnarray*}
\end{remark}


The following lemma shows the equivalence of both definitions.

\begin{lemma}
	Let $A$ be a "DBUA",
	\[ \lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A t \in F} \]
\end{lemma}

\begin{proof}
	We will prove by induction on a "tree"~$t$ that (a) there exists a "run" of~$A$ over~$t$, and (b) for all "runs"~$\exec$ of $A$ over $t$, $\interpret A t = \exec (\varepsilon)$.
	We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$. Let $\rho$ be defined by $\rho(\varepsilon)=\init_a$, then $\rho$ is a "run" of~$A$ over~$t$. We have proved (a).
		      Consider now some "run" $\rho$ of $A$ over~$t$. We have $\rho(\varepsilon)=\init_a=\interpret A a=\interpret A t$. We have proved  (b).

		\item If $t = a(t',t'')$. By induction hypothesis (a), there exists "runs"~$\rho'$ and $\rho''$ on~$t'$ and $t''$ respectively.
		      Let~$\rho$ be defined by $\rho(\varepsilon)=\delta_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon))$,
		      $\rho(0u)=\rho'(u)$ for all $u\in\Nodes{t'}$ and $\rho(1u)=\rho''(u)$ for all~$u\in \Nodes{t''}$. Then $\rho$ is a "run" of~$A$ over $t$. We have proved (a).

		      Consider now some "run" $\rho$ of $A$ over $t$. Let~$\rho'(u)=\rho(0u)$ for all $u \in \Nodes {t'}$ and $\rho''(u)=\rho(0u)$ for all $u \in \Nodes {t''}$.
		      Then $\rho'$ is a "run" of~$A$ over $t'$ and $\rho''$ over $t''$. By induction hypothesis (b) twice, we know that $\rho'(\varepsilon)=\interpret A {t'}$ and $\rho''(\varepsilon)=\interpret A {t''}$.
		      We have now $\rho(\varepsilon) = \delta_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon)) = \delta_{t(\varepsilon)}(\interpret A {t'},\interpret A {t''}) = \interpret A t$. We have proved (b).
	\end{itemize}
\end{proof}


We aim now to show that, like in the classical theory, both non-deterministic automata and deterministic ones have the same expressiveness power.
Since "DBUA" is a particular case of "NBUA" it suffices to show that each "language" accepted by an "NBUA" can also be accepted by a "DBUA".

\begin{definition}
	\AP Let $A = \NBUA$ be a "NBUA", we define the ""power set automaton"" of $A$, noted $\intro* \Det A$, as
	$\Det A = (\Sigma, \parts Q, \init, \delta, F')$ where:

	\begin{itemize}
		\item $\begin{aligned}[t]
				      \init      : \Sigma & \to \parts Q                          \\
				      a                   & \mapsto \setdef{q \in Q}{(a,q) \in I}
			      \end{aligned} $

		\item $\begin{aligned}[t]
				      \delta               : \parts Q \times \parts Q \times \Sigma & \to \parts Q                                                     \\
				      (X, Y, a)                                                     & \mapsto \setdef{q \in Q}{(x,y,a,q) \in \Delta, x \in X, y \in Y}
			      \end{aligned}$

		\item $F' = \setdef{X \in \parts Q}{X \cap F \neq \emptyset} \subseteq \parts Q$
	\end{itemize}
\end{definition}

\begin{theorem}
	For all $N = \NBUA$ an "NBUA", the "power set automaton" verifies that
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} \text{ and } \lang N = \lang {\Det N}
	\]
\end{theorem}

\begin{proof}
	We will first show that for all "tree" $t$,
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}\ .
	\]
	We will prove this property by induction over $t$. We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$, then
		      \begin{eqnarray*}
			      \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} &=&  \setdef {q \in Q} {(a,q) \in I} \\
			      &=& \interpret {\Det N} t\ .
		      \end{eqnarray*}
		\item If $t = a(t_1,t_2)$, then
		      by the induction hypothesis we know that
		      $\interpret {\Det N} {t_i} = q_i$ \tiff there exists a "run" over $t_i$ ending at $q_i$, for $i \in \set {1,2}$.

		      \begin{eqnarray*}
			      &&q \in \interpret {\Det N} t \\
			      &\text{if and only if}& q \in \delta_a (\interpret {\Det N} {t_1}, \interpret {\Det N} {t_2}) \\
			      &\text{if and only if}& q \in \setdef {q \in  Q} {(x_1,x_2,a,q) \in \Delta, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2}} \\
			      &\text{if and only if}& \exists x_1,x_2, (x_1,x_2,a,q) \in \Delta, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2} \\
			      &\text{if and only if}& \text{there exists a "run" over }  t_i  \text { ending at } x_i \text { for  } i \in \set {1,2} \text{ and } (x_1,x_2,a,q) \in \Delta\\
			      &\text{if and only if}& q \in \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}
		      \end{eqnarray*}
	\end{itemize}
	Then $ \interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}$.\\

	We must now show that $\Det N$ "accepts" $t$ \tiff $N$ "accepts" $t$.
	\begin{eqnarray*}
		N \text{ "accepts" } t &\tiff& F \cap \setdef {q \in Q} {(a,q) \in I} \neq \emptyset \\
		&\tiff&   F \cap  \interpret {\Det N} t \neq \emptyset \\
		&\tiff& \interpret {\Det N} t  \in F' \\
		&\tiff& {\Det N} \text{ "accepts" } t
	\end{eqnarray*}
	and so $\lang N = \lang {\Det N}$.
\end{proof}


\subsection{Order-insensitivity}\label{sec:OrderAutomata}

We will interest ourselves in a particular kind of tree automata: the ones that do not distinguish between left and right children.
That means that the state reached from the two children is the same if we swap them. These automata are
interesting because they respect the symmetries of "trees".

\begin{definition}
	\AP An "NBUA" of "transition relation"~$\Delta$ is ""order-insensitive"" if for all "transitions@@relation" $(p,q,a,r) \in \Delta$,
	$(q,p,a,r) \in \Delta$.
\end{definition}

\begin{remark}\label{def:order-insensitive}
	For a "DBUA" of "transition map"~$\delta$, it is "order-insensitive" if and only if
	$\delta_a (p,q) = \delta_a (q,p)$ for all "states"~$p,q$ and letter~$a$.
\end{remark}


\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			level 1/.style={sibling distance=1.5cm},
			every node/.style={draw, circle},
			baseline={(current bounding box.center)}
		]

		% Left Tree
		\node (root1) {$a$}
		child {node {$t_1$}}
		child {node {$t_2$}};

		% Right Tree
		\node (root2) at (6,0) {$a$}
		child {node {$t_2$}}
		child {node {$t_1$}};

		% State s
		\node[draw=blue] (s) at (3, -0.5) {$s$};

		% Arrows
		\draw[->, thick, draw=blue] (root1) to[out=0, in=180] node[draw=none, midway, below] {\(\delta_a\)} (s);
		\draw[->, thick, draw=blue] (root2) to[out=180, in=0] node[draw=none, midway, below] {\(\delta_a\)} (s);

	\end{tikzpicture}
	\caption{Illustration of "order-insensitivity" in a "DBUA" (see \Cref{def:order-insensitive}).
		Both trees yield the same state $s$ under the transition map $\delta_a$.}
	\label{fig:order-insensitivity}
\end{figure}



\begin{lemma}
	If $N = \NBUA$ a "NBUA" is "order-insensitive", then $\Det N$ is also "order-insensitive".
\end{lemma}

\begin{proof}
	\begin{eqnarray*}
		\delta_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \Delta, x \in X, y \in Y}  \reason {$N$ is "order-insensitive"} \\
		&=& \delta_a (Y,X)
	\end{eqnarray*}
\end{proof}

\subsection{Universality}\label{sec:UniversalityAutomata}

In this section, we define the "reachability set" of a "DBUA" and show that it can be used to decide the "universality" of the automaton.

\begin{definition}["Reachability set"]
	\AP Let $A = \DBUA$ a "DBUA", and let $\intro* \Reach A \subseteq Q$ be the smallest set such that:
	\begin{enumerate}
		\item $\init(a) \in \Reach A$ for all $a \in \Sigma$,
		\item $\delta(p, q, a) \in \Reach A$ for all $p, q \in \Reach A$ and $a \in \Sigma$.
	\end{enumerate}
\end{definition}

This set captures all "states" that can be reached by the automaton starting from the "leaves" and combining them using the transition function.
In particular, it represents the set of all "states" that can be reached when the automaton processes all possible "trees", motivating the following lemma.

\begin{lemma}
	Let $A$ be a "DBUA", then:
	\[
	\Reach A = \setdef {\interpret A t} {t \in \tree_\Sigma}.
	\]
\end{lemma}

\begin{proofI}
	We prove the equality by showing both inclusions.
	\begin{itemize}
		\item For the direction $\Reach A \subseteq \setdef {\interpret A t} {t \in \tree_\Sigma}$, we proceed by induction over the construction of elements in $\Reach A$:
		      \begin{itemize}
			      \item If $r = \init(a)$ for some $a \in \Sigma$, then the "tree" $a$ satisfies $\interpret A a = \init(a) = r$.
			      \item If $r = \delta(p, q, a)$ where $p, q \in \Reach A$, then by the induction hypothesis there exist 
                      $t', t'' \in \tree_\Sigma$ such that $\interpret A {t'} = p$ and $\interpret A {t''} = q$. Then the "tree" $t = a(t', t'')$ satisfies $\interpret A t = r$.
		      \end{itemize}

		\item For the direction $\setdef {\interpret A t} {t \in \tree_\Sigma} \subseteq \Reach A$, we use structural induction on the "tree" $t$:
		      \begin{itemize}
			      \item If $t = a$, then $\interpret A a = \init(a) \in \Reach A$.
			      \item If $t = a(t', t'')$, then by the induction hypothesis $\interpret A {t'}, \interpret A {t''} \in \Reach A$, so
			            \[
			            \interpret A t = \delta(\interpret A {t'}, \interpret A {t''}, a) \in \Reach A.
			            \]
		      \end{itemize}
	\end{itemize}
\end{proofI}

\begin{definition}
	\AP Let $A$ be a "NBUA". We say that $A$ is "universal" if it "accepts" every "tree".
\end{definition}

Once we have defined the "reachability set", we can use it to decide whether an automaton is "universal". Intuitively, a "DBUA" is "universal" if 
the only "states" it can reach are "final states". This is formalized in the following theorem.

\begin{theorem}
	A "DBUA" $A = \DBUA$ is "universal" if and only if $\Reach A \subseteq F$.
\end{theorem}

\begin{proofI}
	\begin{itemize}
		\item Suppose $A$ is "universal". Then for all $t \in \tree_\Sigma$, we have $\interpret A t \in F$ because $A$ "accepts" $t$.
		      Since $\Reach A = \setdef {\interpret A t} {t \in \tree_\Sigma}$, we conclude that $\Reach A \subseteq F$.

		\item Conversely, suppose $\Reach A \subseteq F$. For any "tree" $t \in \tree_\Sigma$, we have $\interpret A t \in \Reach A \subseteq F$.
		      Hence, $A$ "accepts" $t$ and is therefore "universal".
	\end{itemize}
\end{proofI}

\begin{coro}\label{coro:univeral-Reach}
	A saturation algorithm based on $\Reach A$ decides "universality".
\end{coro}

We have now defined an algorithm to decide whether a "DBUA" is "universal". 
This result will be used in \Cref{sec:uniformisation} to decide "uniformisation".

\subsection{Monadic second-order logic}\label{sec:MSO}

\todo{maybe define what mso actually is and talk a bit more about models}
In this subsection, we introduce "monadic second-order logic" ("MSO") over finite binary "trees",
and examine its relationship with "non-deterministic bottom-up automata", in partivulat with "order-insensitive" automata.

We will use this equivalence later to reason about "MSO" formulas using automata-theoretic techniques. In particular, this will allow us to:

Our objective is to show that "MSO" and "order-insensitive" "automata@NBUA" have the same expressive power. This will allow to reason about
properties of "MSO" using automata theory techniques, wich will be extensively use in \Cref{sec:uniformisation}.

The proof follows the classical schema.

We start by showing that every "automaton@NBUA" can be expressed as a formula. The proof itself is standard \cite{Buchi60, Thomas1997, bookautomata}.

\begin{definition}
	\AP Let $t \in \tree_{\Sigma}$. We define a ""model"" of $t$ as:

	\[
		\intro* \Model t := (\Nodes t, \ancestor , (a (x))_{a \in \Sigma})
	\]

	where each unary predicate $a(x)$ holds if and only if $\tlabel t x = a$.

	We write $t \models \phi$ to mean that the formula $\phi$ holds in the "model" $\Model t$.
\end{definition}

We will discuss some examples of "MSO" formulas.

\begin{example}
	\AP The formula
	\[
		\intro* \leaf(x) = \forall y,\, y \ancestor x
	\]
	expresses the fact that $x$ is a "leaf", a node without descendants.
\end{example}

\begin{example}
	\AP The formula
	\[
		\intro* \treeroot(x) = \forall y,\, x \ancestor y
	\]
	defines the "root" of the "tree", meaning a node that is an "ancestor" of every other node.
\end{example}

\begin{example}
	\AP The following formula expresses that $x$ and $y$ are the immediate children of a node $z$:
	\[
		\intro* \children(x,y,z) =
		x \neq y \land
		z \ancestor x \land  z \ancestor y \land
		\forall w
		\left( \left(
			z \ancestor w \land
				(w \ancestor x \lor w \ancestor  y) \right) \rightarrow (
			w = x \lor w = y
			)
		\right)
	\]
\end{example}

We now show how to simulate an "automaton@NBUA" by a formula. The idea is to encode the existence of a valid "run" of
the "automaton@NBUA" using second-order variables that assign "states" to "nodes".

\begin{lemma}
	If $A$ is an "order-insensitive" "NBUA", then there exists a "MSO" formula $\phi$ such that for all $t \in \tree_{\Sigma}$,
	\[
		t \models \phi \tiff t \in \lang A.
	\]
\end{lemma}

\begin{proof}\label{lem:Aut-to-MSO}
	Let $A = \NBUA$ be an "order-insensitive" "NBUA", and let $k = \abs Q$ be the number of "states".
	\todo{write something up here and move the formula to an annex}
	\begin{align}
		\phi =\  & \exists X_0 \ldots \exists X_{k-1} \ \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \label{lem:AMSO1}                                                                                    \\
		         & \land\ \forall x \left( \bigwedge_{0 \leq i < j \leq k-1} \lnot (X_i(x) \land X_j(x)) \right) \label{lem:AMSO2}                                                                               \\
		         & \land\ \forall x \left( \leaf(x) \rightarrow \bigvee_{(a,i) \in I} X_i(x) \right) \label{lem:AMSO3}                                                                                           \\
		         & \land\ \forall x\, \forall y\, \forall z \left(\children(x,y,z) \rightarrow \bigvee_{(p,q,a,r) \in \Delta} \left(X_p(x) \land X_q(y) \land a(z) \land X_r(z)\right) \right) \label{lem:AMSO4} \\
		         & \land\ \forall x \left( \treeroot(x) \rightarrow \bigvee_{q \in F} X_q(x) \right) \label{lem:AMSO5}
	\end{align}

	The sets $X_i$ encode the "run" of the automaton: $x \in X_i$ means that the "state" $i$ is assigned to the "node" $x$ in some valid accepting "run".

	The formula ensures:

	\begin{itemize}
		\item[\ref{lem:AMSO1}] Every "node" is assigned some "state".
		\item[\ref{lem:AMSO2}] No "node" is in more than one "state".
		\item[\ref{lem:AMSO3}] "Leaf" nodes are assigned an initial "state".
		\item[\ref{lem:AMSO4}] For each triple $(x,y,z)$ forming a parent and its two children,
		      there exists a transition in $\Delta$ from the children to the parent.
		\item[\ref{lem:AMSO5}] The "root" is labeled with a final "state".
	\end{itemize}

	Therefore, the formula defines the same "language" as the automaton:
	\[
		t \models \phi \iff t \in \lang A.
	\]
\end{proof}

We now turn to the other direction. Our goal is to show that for every "MSO" formula over finite binary "trees",
there exists an equivalent "order-insensitive" "non-deterministic bottom-up automaton".

The construction proceeds by induction on the structure of formulas, using standard constructions for closure and the atomic formulas.
Throughout, we ensure that the resulting automata remain "order-insensitive".

We begin with basic closure properties of such automata.

\begin{lemma}[Intersection]\label{lem:intersection}
	Let $A_1 = (\Sigma, Q_1, I_1, \Delta_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \Delta_2, F_2)$ be two "order-insensitive" "NBUAs". Then the product automaton
	\[
		A_3 = (\Sigma, Q_1 \times Q_2, I_1 \times I_2, \Delta, F_1 \times F_2),
	\]
	where
	\[
		\Delta = \left\{ ((q_1,q_2), (p_1,p_2), (a_1,a_2), (r_1,r_2)) \,\middle|\, (q_1,p_1,a_1,r_1) \in \Delta_1,\ (q_2,p_2,a_2,r_2) \in \Delta_2 \right\},
	\]
	is "order-insensitive", and satisfies $\lang{A_3} = \lang{A_1} \cap \lang{A_2}$.
\end{lemma}

\begin{lemma}[Union]\label{lem:union}
	Let $A_1 = (\Sigma, Q_1, I_1, \Delta_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \Delta_2, F_2)$ be two "order-insensitive" "NBUAs". Then the disjoint union
	\[
		A_3 = (\Sigma, Q_1 \uplus Q_2, I_1 \uplus I_2, \Delta_1 \uplus \Delta_2, F_1 \uplus F_2)
	\]
	is also "order-insensitive", and it accepts precisely the union of the two languages: $\lang{A_3} = \lang{A_1} \cup \lang{A_2}$.
\end{lemma}

\begin{lemma}[Complement]\label{lem:complement}
	Given an "order-insensitive" "NBUA" $A = (\Sigma, Q, I, \Delta, F)$, the automaton
	\[
		A' = (\Sigma, Q, I, \Delta, Q \setminus F)
	\]
	is also "order-insensitive", and recognizes the complement of $A$: $\lang{A'} = \lang{A}^\complement$.
\end{lemma}

We now turn to atomic formulas. These are handled by explicitly designed automata over expanded alphabets that encode variable assignments.
\todo{explain expanded alphabets and annotated trees}

\todo{maybe move these automata to the annex}

\begin{lemma}\label{lem:atomic-a}
	Let $a \in \Sigma$. Over the alphabet $\Sigma \times \{0,1\}$, there exists an "order-insensitive" automaton deciding the atomic predicate $a(x)$, where $x$ is a free first-order variable. Define:
	\[
		A = (\Sigma \times \{0,1\}, \{\text{Yes}, \text{No}\}, \init, \delta, \text{Yes}),
	\]
	where:
	\begin{itemize}
		\item
		      \[
			      \init(a,1) = \text{Yes}, \quad \init(\_,\_) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \delta(\_, \_, (a,1))            & = \text{Yes} \\
				      \delta(\text{No}, \text{No}, \_) & = \text{No}  \\
				      \delta(\_, \_, \_)               & = \text{Yes}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}\label{lem:atomic-ancestor}
	There exists an "order-insensitive" automaton over $\Sigma \times \{0,1\}^2$ that decides the formula $x \ancestor y$. We define:
	\[
		A = (\Sigma \times \{0,1\}^2, \{\text{Yes}, \text{No}, \text{FoundY}\}, \init, \delta, \text{Yes}),
	\]
	with the following behavior:
	\begin{itemize}
		\item
		      \[
			      \init(\_,\_,1) = \text{FoundY}, \quad \init(\_,\_,0) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \delta(\text{FoundY}, \_, (\_,1,0)) & = \text{Yes}    \\
				      \delta(\_, \text{FoundY}, (\_,1,0)) & = \text{Yes}    \\
				      \delta(\text{FoundY}, \_, (\_,0,0)) & = \text{FoundY} \\
				      \delta(\_, \text{FoundY}, (\_,0,0)) & = \text{FoundY} \\
				      \delta(\text{Yes}, \_, \_)          & = \text{Yes}    \\
				      \delta(\_, \text{Yes}, \_)          & = \text{Yes}    \\
				      \delta(\_, \_, (\_,0,1))            & = \text{FoundY} \\
				      \delta(\_, \_, \_)                  & = \text{No}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}[from MSO to automata]\label{lem:MSO-to-aut}
	Let $\phi$ be an MSO formula. Then there exists an "order-insensitive" "NBUA" $A$ such that for every $t \in \tree_\Sigma$, we have:
	\[
		t \models \phi \quad \text{if and only if} \quad t \in \lang{A}.
	\]
\end{lemma}

\begin{proof}
	The construction proceeds by structural induction on $\phi$.

	Formulas such as $a(x)$ and $x \ancestor y$ are handled directly by the automata
	in \Cref{lem:atomic-a,lem:atomic-ancestor}, which operate over trees annotated with assignments to free variables.

	For conjunction and disjunction, we apply the induction hypothesis to obtain automata
	for the subformulas, then use the constructions from \Cref{lem:intersection,lem:union} to obtain an automaton for the whole expression.

	If $\phi = \lnot \psi$, then by the induction hypothesis we obtain an automaton for $\psi$. We apply
	\Cref{lem:complement} to obtain an automaton for $\phi$.

	Assume $\phi = \exists x.\psi(x)$, where $\psi$ has $n$ free variables and $x$ is the $n$-th one.

	By the induction hypothesis, we have an "order-insensitive" "DBUA" (since avery "NBUA" can be converted to a "DBUA")
	\[
		A = (\Sigma \times \{0,1\}^n, Q, \init, \delta, F)
	\]
	that accepts the language of $\psi(x)$, where we assume the input "trees" "annotated" with $n$ bits per "node" and the $n$-th bit indicates
	whether the node is assigned to $x$.

	We now construct an automaton that operates over $\Sigma \times \{0,1\}^{n-1}$, where $x$ is no longer explicitly assigned.
	Instead, we simulate all possible annotations for $x$, and accept if at least one such "annotation" makes $\psi(x)$ true.

	Define the new automaton:
	\[
		A' = (\Sigma \times \{0,1\}^{n-1}, \parts Q, \init', \delta', F')
	\]
	where:
	\begin{itemize}
		\item Initial state set:
		      \[
			      \init'(a, \vec{b}) = \setdef{ \init(a, \vec{b}, b')} {b' \in \{0,1\} }
		      \]
		      That is, we simulate both possibilities for the missing $x$-bit.
		\item "Transition map":
		      \[
			      \delta'(P, Q, (a, \vec{b})) = \setdef{ \delta(p, q, (a, \vec{b}, b'))} {p \in P,\ q \in Q,\ b' \in \{0,1\} }
		      \]
		      Again, for every guess of $x$’s value at this "node", we compute the next "state" as if that guess were part of the input.
		\item "Accepting states":
		      \[
			      F' = \setdef{ P \subseteq Q} {P \cap F \neq \emptyset }
		      \]
		      The automaton accepts if one of the runs under some assignment for $x$ ends in an "accepting state".
	\end{itemize}

	This automaton simulates all possible choices of a "node" for $x$, \ie, all possible  bit "annotations" for the $x$-variable.
	Since $A$ is "order-insensitive", and the construction treats all "nodes" symmetrically, $A'$ is also "order-insensitive".

	For $\phi = \exists X.\psi(X)$, the construction is similar. The automaton $A$ reads $n$-bit "annotations", with the last bit corresponding
	to the second-order variable $X$. We define $A'$ by again simulating all two options for each node (being in $X$ or not) and applying the same
	"powerset construction".

	Each inductive case preserves "order-insensitivity", and constructs an "NBUA" for the given formula. Thus, by induction on the structure of $\phi$,
	we obtain the desired automaton.
\end{proof}


\section{Uniformisation}\label{sec:uniformisation}
 2
In this section we are going to formally define what "uniformisation" is, give some intuition about it,
propose an algorithm that decides "uniformization" on finite binary trees and prove its correctness and soundness.
The main result is \Cref{thm:uniformisability-decision}.

\subsection{Definitions}

We begin by formalising the core concepts.

\begin{definition}label{def:uniformiser}
	\AP A formula $\psi(X)$ is a ""uniformiser"" of a formula $\phi(X)$ if, for all "trees" $t$, the following hold:
	\begin{enumerate}
		\item There exists at most one set $X$ such that $t \models \psi(X)$.
		\item If there exists a set $X$ such that $t \models \phi(X)$, then there exists a set $Y$ such that $t \models \psi(Y) \land \phi(Y)$.
	\end{enumerate}
\end{definition}

\AP A formula $\phi(X)$ is said to be ""uniformisable"" if it admits a "uniformiser".

Another way to express this is that $\phi(X)$ is "uniformisable" if there exists $\psi(X)$ such that, for every "tree" $t$:
\[
	t \models \exists X.\, \phi(X) \quad \Rightarrow \quad t \models \phi(\setdef{x}{t \models \psi(x)}).
\]

This global property ensures that the formula $\psi$ extracts, uniformly, one solution for $\phi$ when one exists.

\begin{definition}[""Definable set""]\label{def:definable}
	\AP Let $t$ be a "tree". A set $X \subseteq \Nodes(t)$ is said to be ""definable"" if there exists an
	"MSO" formula $\phi(x)$ such that $X = \setdef{x}{t \models \phi(x)}$.
\end{definition}

In particular, if $\phi(X)$ is "uniformisable", then for every "tree" $t$ such that $t \models \exists X. \phi(X)$,
there exists a "definable" $X_d$ such that $t \models \phi(X_d)$.

Thus, "definability" expresses the local property of describing a solution on a given "tree", while "uniformisability" expresses
a global capacity to do so uniformly across all "trees".


One key concept in this section will be the use of "automorphisms" of "trees".

\begin{definition}["Automorphism"]\label{def:automorphism}
	\AP An ""automorphism"" of a "tree" $t$ is a bijection $\sigma : \Nodes(t) \to \Nodes(t)$ preserving the tree structure:
	if $u$ is a child of $v$, then $\sigma(u)$ is a child of $\sigma(v)$, and $\sigma$ preserves the labels of nodes.
	The group of all automorphisms of $t$ is denoted $\intro* \Aut(t)$.
\end{definition}

In other words, an "automorphism" is a symmetry of the "tree" that rearranges its nodes while preserving the structure and labels.
Let us illustrate this concept with an example.

\begin{example}
	Consider the complete binary tree of height 2 and its image under an "automorphism" $\sigma$ that swaps the left and right subtrees:
	\[
		\begin{tikzpicture}[baseline={(current bounding box.center)}]
			\node (left) at (0,0) {
				\begin{tikzpicture}[level distance=1.2cm,
						every node/.style={draw, circle, minimum size=7mm},
						level 1/.style={sibling distance=2cm},
						level 2/.style={sibling distance=1cm}]
					\node {r}
					child { node[fill=blue!20] {a}
							child {node[fill=green!20] {b}}
							child {node[fill=green!20] {c}} }
					child { node[fill=red!20] {d}
							child {node[fill=yellow!20] {e}}
							child {node[fill=yellow!20] {f}} };
				\end{tikzpicture}
			};

			\node (right) at (6,0) {
				\begin{tikzpicture}[level distance=1.2cm,
						every node/.style={draw, circle, minimum size=7mm},
						level 1/.style={sibling distance=2cm},
						level 2/.style={sibling distance=1cm}]
					\node {r}
					child { node[fill=red!20] {d}
							child {node[fill=yellow!20] {e}}
							child {node[fill=yellow!20] {f}} }
					child { node[fill=blue!20] {a}
							child {node[fill=green!20] {b}}
							child {node[fill=green!20] {c}} };
				\end{tikzpicture}
			};

			\draw[->, thick] (2,0) -- (4,0) node[draw=none,midway, above] {$\sigma$};
		\end{tikzpicture}
	\]

	The "automorphism" $\sigma$ swaps the left and right subtrees of the root, mapping: $a \leftrightarrow d$, $b \leftrightarrow e$, $c \leftrightarrow f$.
	This is possible because both "subtrees" are structurally identical and their "node labels" align symmetrically.
\end{example}

\begin{remark}
	Consider this asymmetric "tree":
	\[
		\begin{tikzpicture}[level distance=1.2cm,
				every node/.style={draw, circle, minimum size=7mm},
				level 1/.style={sibling distance=2cm},
				level 2/.style={sibling distance=1cm}]
			\node {r}
			child { node[fill=blue!20] {a} }
			child { node[fill=red!20] {d}
					child {node[fill=green!20] {e}}
					child {node[fill=green!20] {f}} };
		\end{tikzpicture}
	\]

	This "tree" admits only two "automorphisms": the identity, and the one that swaps $e$ and $f$.
	An "automorphism" cannot map $a \leftrightarrow d$ because their subtrees differ: $a$ is a leaf, while $d$ has children.
	Thus, there is no bijection that can preserve both the structure and labels in such a case.
\end{remark}


\subsection{Intuition behind the main result}

We are interested in checking whether a given formula $\phi(X)$ has a "uniformiser".
Our approach is to consider a more manageable property: whether $\phi(X)$ is "globally definable".

\begin{definition}["Globally definable"]\label{def:global-def}
	\AP A formula $\phi(X)$ is ""globally definable"" if, for every "tree" $t$, the following holds:
	\[
		t \models \exists X.\, \phi(X) \quad \Rightarrow \quad \text{there exists a "definable" } X_d \text{ such that } t \models \phi(X_d).
	\]
\end{definition}

Clearly, if a formula is "uniformisable", then it is also "globally definable". The surprising part- and one of our results- is that the converse also holds.
That is, "global definability" implies "uniformisability". This equivalence is established in \Cref{lem:main-result}.

The rest of this section is devoted to expressing "global definability" in terms of automata, constructing a suitable "deterministic bottom-up automaton",
and reducing the problem to an "automata universality" check.

\subsection{Algorithm and the main result}

Let us fix a formula $\phi(X)$. Consider the implication:
\[
	(\exists X.\, \phi(X)) \rightarrow (\exists X.\, \phi(X) \text{ and $X$ is "definable"}).
\]
We aim to build an automaton that accepts exactly the "trees" where this formula holds. If this automaton is "universal", then $\phi(X)$ is "globally definable".

As a warm-up, we consider a similar implication involving two formulas $\phi(X)$ and $\psi(Y)$:
\[
	\Psi := (\exists X.\, \phi(X)) \rightarrow (\exists Y.\, \psi(Y)).
\]
This is an "MSO" formula, and using \Cref{lem:MSO-to-aut}, we can construct equivalent "DBUA"s $A_\phi$ and $A_\psi$.

We now define a new automaton $A$ capturing the semantics of $\Psi$.

\begin{notation}
	We write $\delta(X,Y,(a,*))$ for $\bigcup_{b \in \set{0,1}} \delta(X,Y,(a,b))$, and $\init(a,*)$ for $\bigcup_{b \in \set{0,1}} \init(a,b)$.
\end{notation}

We define a "DBUA" $A = (\Sigma, \parts{Q_\phi} \times \parts{Q_\psi}, \init, \delta, F)$ as follows:
\begin{itemize}
	\item $\init(a) = (\init_\phi(a,*), \init_\psi(a,*))$
	\item $\delta((X,X'),(Y,Y'),a) = (\delta_\phi(X,Y,(a,*)), \delta_\psi(X',Y',(a,*)))$
	\item $F = \setdef{(X,X')}{(X \cap F_\phi \neq \emptyset) \Rightarrow (X' \cap F_\psi \neq \emptyset)}$
\end{itemize}

$A$ accepts a "tree" $t$ if and only if $t \models \Psi$. Hence, testing whether $A$ is universal gives a decision procedure for the validity of $\Psi$ over all "trees".

To decide "uniformisability", we build a modified automaton that ensures the witness is "definable".

\begin{definition}["Uniformiser automaton"]
	\AP Let $\phi(X)$ be an "MSO" formula and $A = (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ its "DBUA". The ""uniformiser automaton"" is defined as
	\[
		\intro* \Ua = (\Sigma, \parts{Q} \times \parts{Q}, \init_U, \deltau, F')
	\]
	where:
	\begin{itemize}
		\item $\init_U(a) = (\init(a,*), \init(a,*))$
		\item $\deltau((X,X'),(Y,Y'),a) = (\delta(X,Y,(a,*)), \deltauu(X',Y',a))$ with:
		      \[
			      \deltauu(X',Y',a) = \begin{cases}
				      \setdef{\delta(p,p,(a,b))}{p \in X', b \in \set{0,1}} & \text{if } X' = Y' \\
				      \delta(X',Y',(a,*))                                   & \text{otherwise}
			      \end{cases}
		      \]
		\item $F' = \setdef{(X,X')}{(X \cap F \neq \emptyset) \Rightarrow (X' \cap F \neq \emptyset)}$
	\end{itemize}
\end{definition}


Intuitively, $\Ua$ checks whether $\phi(X)$ has a witness, and attempts to reconstruct a "definable" one using symmetry constraints.
If no structural difference between left and right can be observed, the automaton forces them to behave identically, guaranteeing
"definability" by symmetry.

Each state of the "uniformiser automaton" is a pair of sets of states of the original automaton for $\phi$.
The first component represents a standard run of the original automaton (checking if the formula $\phi(X)$
is satisfiable), while the second component simulates a restricted run that is meant to capture a "definable" witness.
When both sides behave identically on a given "subtree", that is, when the shape and annotations of the tree do not allow
us to distinguish between them, the automaton enforces that they must transition identically, ensuring symmetry. This restriction
is what guarantees "definability": the selected witness must be invariant under all "automorphisms" of the "tree".

\begin{definition}["Uniformisability checking algorithm"]
	\AP Given an "MSO" formula $\phi(X)$, the ""uniformisability checking algorithm"" constructs the "uniformiser automaton" $\Ua$ for $\phi(X)$ and checks whether it is universal,
	using the algorithm from \Cref{coro:univeral-Reach}.
	If $\Ua$ is universal, then $\phi(X)$ is "uniformisable", and the algorithm returns a "uniformiser" for $\phi(X)$. Otherwise, it concludes that $\phi(X)$ is not "uniformisable".
\end{definition}

In the rest of this section, we will prove that this algorithm is correct and sound, leading to the main result of this article, \Cref{thm:uniformisability-decision}.


\subsection{Proof of the Main Result}

We now state the main result of this section, which establishes the equivalence between "uniformisability", "global definability", symmetries on "trees", and the universality of the "uniformiser automaton".
This result leads to a decision procedure for "uniformisability" by checking the universality of the "uniformiser automaton".

\begin{lemma}\label{lem:main-result}
	Let $\phi(X)$ be an "MSO" formula and $\Ua$ its corresponding "uniformiser automaton". Then the following are equivalent:
	\begin{enumerate}
		\item $\phi(X)$ is "uniformisable". \label{lem:main-result-1}
		\item $\phi(X)$ is "globally definable". \label{lem:main-result-2}
		\item For all "trees" $t$, if $t \models \exists X. \phi(X)$ then there exists $X$ such that $t \models \phi(X)$ and $\sigma(X) = X$ for all $\sigma \in \Aut(t)$. \label{lem:main-result-3}
		\item The "uniformiser automaton" $\Ua$ is "universal". \label{lem:main-result-4}
	\end{enumerate}
\end{lemma}

One can note that the implication \ref{lem:main-result-1} $\Rightarrow$ \ref{lem:main-result-2} is straightforward, as a "uniformiser" provides a "definable" witness.
The following sections will show the remaining implications.

We can then deduce the main result of this article:
\begin{theorem} \label{thm:uniformisability-decision}
	There exists a decision procedure for "uniformisability" of "MSO" formulas over finite binary "trees" that
	also effectively constructs a "uniformiser" if the formula is "uniformisable".
\end{theorem}

\begin{proof}
	The equivalence in \Cref{lem:main-result} prove that the "uniformiser automaton" $\Ua$ is universal if and only if $\phi(X)$ is "uniformisable", so using the
	"uniformisability checking algorithm", we can decide whether $\phi(X)$ is "uniformisable" and construct a "uniformiser" if it is.

	The proof of correctness exposed in \Cref{sec:correctness} provides said "uniformiser",$\unif(X)$, if the algorithm concludes that $\phi(X)$ is "uniformisable".
\end{proof}


The implication \ref{lem:main-result-1} $\Rightarrow$ \ref{lem:main-result-2} is straightforward, as a "uniformiser" provides a "definable" witness.
In the rest of the article, we will show the remaining implications.

\subsection{Definability and automorphisms}

The implication \ref{lem:main-result-2} $\Rightarrow$ \ref{lem:main-result-3} follows directly from a key property of "definable" sets:

\begin{lemma}\label{lem:def-aut}
	If $X$ is "definable" over a "tree" $t$, then for all $\sigma \in \Aut(t)$, we have $\sigma(X) = X$.
\end{lemma}

\begin{proof}
	If $X$ is "definable", there exists an "MSO" formula $\phi(x)$ such that $X = \setdef{x}{t \models \phi(x)}$.
	We want to show that for all $\sigma \in \Aut(t)$ and all $x \in X$, we have $t \models \phi(\sigma(x))$.
	Since $\sigma$ is a bijection, this suffices to conclude $\sigma(X) = X$.

	The idea is that an MSO formula, by construction, cannot distinguish between "nodes" that are mapped to each other by "automorphisms":
	these transformations preserve the structure and labels of the "tree".

	The proof proceeds by induction on the structure of $\phi$. Atomic formulas are invariant under "automorphisms" by definition,
	since "automorphisms" preserve the tree structure and labeling. The logical connectives (conjunction, disjunction, negation)
	and quantifiers preserve this invariance, so the property holds inductively.

	Therefore, for all $x \in X$, we have $t \models \phi(x) \Rightarrow t \models \phi(\sigma(x))$, and hence $\sigma(x) \in X$. Thus, $\sigma(X) = X$.
\end{proof}

This lemma allows us to reason about "definable" sets in terms of their invariance under "automorphisms",
which often makes them easier to identify in practice. It also forms a conceptual bridge between "definability" and symmetry:
"automorphisms" reflect the symmetries of the "tree", and "definable" sets must respect those symmetries.


\subsection{Correctness}\label{sec:correctness}

We now prove the correctness of the "uniformisability checking algorithm" described in \Cref{sec:uniformisation}, by proving the
implication \ref{lem:main-result-4} $\Rightarrow$ \ref{lem:main-result-1}.

\begin{lemma}
	Let $\phi(X)$ be an MSO formula, if the "uniformiser automaton" $\Ua$ of $\phi$ is "universal" then $\phi$ is "uniformisable".
\end{lemma}

\begin{proof}
	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$\Ua = (\Sigma, \parts Q \times \parts Q,\init', \delta', F')$ the "uniformiser automaton" of $\phi$ is universal.
	We need to exhibit a "uniformiser" for $\phi(X)$.

	\AP We first introduce a choice function $\intro*\choiceN : \parts Q \times \parts Q \times Q \times \Sigma \to Q \times Q \times \set{0,1}$
	that given $(X',Y',r,a)$ chooses a triple $(b,p,q)$ such that, if $r \in \deltauu(X',Y', a)$ then $\delta(p,q,(a,b)) = r$ where $p \in X', q \in Y'$
	and if $X' = Y'$ then $p = q$.
	We also introduce $\intro* \choiceL : Q \times \Sigma \to \set{0,1} $, which chooses
	$b$ such that $p = \init((a,b))$.
	Finally, we need to choose from a final state: $\intro* \choiceF : \parts Q \to  Q$ where
	$\choiceF (X) = q$ such that if $X \cap F \neq \emptyset$ then $q \in X \cap F$. If the premises are not satisfied in any of the cases, then
	these choice functions return an arbitrary value.

	\AP We define the set $X_U$ and the "run" $\intro*\rhou$  by induction on the depth of the node as follows:
	\begin{itemize}
		\item For the root, we define $\rhou(\varepsilon) = \choiceF(\deltauu(t))$.
		\item For all inner nodes $x$ with children $y$ and $z$. Let $(p,q,v)$ be $\choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), \rhou(x), \tlabel t x)$, we define
		      $\rhou(y)=p$, $\rhou(z)=q$, and $x \in X_U$ if and only if $b = 1$.
		\item For all "leaves" $x$, let $b$ be ~$b = \choiceL(p, \tlabel t x)$ we define $\rhou (x) = p$, where $x \in X_U$ if and only if $b = 1$.
	\end{itemize}

	We claim now that the $\rhou$ is well defined, unique, and a "run" of $A$ over $(t,X_U)$. The proof procedes by top-down induction.
	\begin{itemize}
		\item For $\varepsilon$, the "root" of $t$, we have that $\rhou(\varepsilon) = \choiceF(\deltauu(t))$, since $\choiceF$ is deterministic, $\rhou(\varepsilon)$ is unique.
		\item For the inner nodes $x$ with children $y$ and $z$, there exists $r \in Q$, such that $\rhou (x) = r$ by the induction hypothesis. Then,
		      since $\choiceN$ is deterministic, there exists a unique tuple $(p,q,b)$ such that
		      $(p,q,b) = \choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), r, \tlabel t x)$.
		      We have that $\rhou(y) = p$ and $\rhou(z) = q$, which verify that $\delta(p,q,(\tlabel t x,b)) = r$. We also have that $x \in X_U$ \tiff $b = 1$.
		      This is then a valid "run" of $A$ over $(t,X_U)$
		\item For a "leaf" $x$ of "label" $a$, by the induction hypothesis we have that $b = \choiceL(a, \rhou(x))$ which is well defined since $a \in \Sigma$ and unique.
		      We also have that $x \in X$ \tiff $b = 1$ and $\rho(x) = \init ((a,b))$.
	\end{itemize}
	The claim is proved. In particular, this run satisfies the restrictions of $\deltauu$ and it's a run over the second projection of $\Ua$.

	\AP We are now ready to define a formula $\intro*\unif (X)$ that witnesses that $\phi$ is "uniformisable".
	This formula simply states using the MSO-syntax the existence of the run $\rhou$ described above, \ie,
	\[  t \models \unif(X) \text{ \tiff } X=X_U \]


	\AP Given a set of "states" $P$, from \Cref{lem:MSO-to-aut} there exists a formula $\intro* \ustate_P(x)$ such that
	\[ t \models \ustate_P(x) \text{ if and only if } \deltauu(\subtree t x) = P .\]

	Let $k = \abs Q$.
	\todo{maybe move to annex ?}
	We define 5 subformulas :

	\begin{eqnarray*}
		\AP \intro* \singleState (X_{p_1}, \ldots, X_{p_k})  &=& \forall x, \bigvee_{1 \leq i \leq k} X_{p_i} (x)\\
		&\land& \forall x, \bigwedge_{1 \leq i, j \leq k, i \neq j} \lnot(X_{p_i} (x) \land X_{p_j}(x))
	\end{eqnarray*}

	\begin{equation*}
		\AP \intro*	\rootNode (X_{p_1}, \ldots, X_{p_k})  = \forall x, \treeroot(x) \ra (\bigvee_{p_i \in \choose \deltauu(\varepsilon)} X_{p_i}(x))
	\end{equation*}

	\begin{equation*}
		\AP \intro* \inSet (X, x, b)  = (\bigwedge_{b = 1}  X(x)) \land (\bigwedge_{b = 0}  \lnot X(x))
	\end{equation*}

	\begin{equation*}
		\AP \intro* \leafNode (X_{p_1}, \ldots, X_{p_k})  = \forall x \left( \leaf(x) \rightarrow \bigvee_{\substack{(a, q) \in \init,\\ \choiceL(a,q) = b}} X_i(x) \land  \text{in\_set}(X,x,b)  \right)
	\end{equation*}
	\AP
	\begin{eqnarray*}
		\intro* \innerNodes (X_{p_1}, \ldots, X_{p_k}, X)  &=& \forall x \forall y, \forall z, \children (x,y,z) \ra \\
		&& \bigvee_{ \substack{(P',Q',a,R')\in \deltauu, \, r \in R', \\ \choiceN(P',Q',a,r) = (p,q,b)}} \Big( \ustate_{P'}(x) \land \ustate_{Q'}(y) \\
		&& \qquad \land \  X_p(x) \land X_q(y) \land a(z) \land X_r(z) \land  \text{in\_set}(X,x,b)\Big)
	\end{eqnarray*}


	We can now define $\unif(X)$:
	\begin{eqnarray*}
		\unif (X) &=& \exists X_{p_1}, \ldots, \exists X_{p_k}, \singleState (X_{p_1}, \ldots, X_{p_k}) \\
		&\land& \leafNode (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \rootNode (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \innerNodes (X_{p_1}, \ldots, X_{p_k}, X)
	\end{eqnarray*}
	$\unif(X)$ describes the run $\rhou$ over $(t,X_U)$ and has a unique solution, $X_U$.

	Let's show that $\unif(X)$ is a "uniformiser" for $\phi(X)$.
	If $\Ua$ is universal the we have that, whenever $\phi(X)$ has a solution for a tree $t$, then there exists an accepting "run" $\rho$ of $\Ua$ over $t$
	such that $\rho(\varepsilon) = (X,X')$ and such that $X \cap F \neq \emptyset$. Since the run is accepting $X' \cap F \neq \emptyset$, and we have that
	$\rhou$ is then well defined and $\unif(X)$ has a solution. Since $\rhou$ is a run of $A$, then we have that $X_U$ is also a solution of $\phi(X)$, so
	$\unif(X)$ is indeed a "uniformiser" for $\phi(X)$.

\end{proof}

\subsection{Soundness}\label{sec:soundness}

\begin{lemma}
	Let $\phi(X)$ be and MSO formula, if $\phi(X)$ is "uniformisable" then the "uniformiser automaton" $\Ua$ of $\phi(X)$ is "universal".
\end{lemma}

\begin{proof}
	We will prove it by contraposition.

	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$\Ua = (\Sigma, \parts Q \times \parts Q,\init', \delta', F')$ the "uniformiser automaton" of $\phi$ is not universal.
	We will show that $\phi(X)$ is not "uniformisable".

	Since $\Ua$ is not "universal", there exists $(R,R') \in \Reach \Ua$, such that $R \cap F \neq \emptyset$ and $R' \cap F = \emptyset$.
	We want to define a "tree" $t_{R,R'}$ such that
	\begin{enumerate}
		\item $R \subseteq \{ \delta_A (t_{R,R'},X) : X \subseteq \Nodes {t_{R,R'}}\}$ \label{lem:prop1}
		\item $\{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \subseteq R'$\label{lem:prop2}
		\item $\interpret \Ua {t_{R,R'}} = (R,R')$\label{lem:prop3}
	\end{enumerate}

	Using \Cref{lem:def-aut}, if we prove that $\{ \delta_A (t_{R,R'},X) : \forall \sigma \in \Aut(t_{R,R'}), \sigma(X) = X\} \subseteq R'$ we also
	satisfy \ref{lem:prop2}.

	We prove by induction that $(T,T') \in \Reach \Ua$ implies all of the three conditions.

	If $(T,T') = (\init(a,*), \init (a, *))$ for $a \in \Sigma$, then \ref{lem:prop1} and \ref{lem:prop3} are trivially satisfied and we have that
	$\Aut (a) = \{\text{id}\}$, so \ref{lem:prop2} is also satisfied.

	If $(T,T') = \delta_U((P,P'),(Q,Q'),a)$ for $a \in \Sigma$ and $P,P',Q,Q' \in \Reach \Ua$, then by the induction hypothesis there exists
	$t_{P,P'}$ and $t_{Q,Q'}$ that verify the hypothesis. We can construct $t_{T,T'} = a(t_{P,P'},t_{Q,Q'})$. Lets prove that it satisfies the
	three properties.

	Lets begin by proving \ref{lem:prop3}.
	By definition of $\interpret \Ua {\cdot}$,
	$\interpret \Ua {t_{T,T'}} = \delta_U (\interpret \Ua {t_{P,P'}}, \interpret \Ua {t_{Q,Q'}}, a)$.
	If we use the induction hypothesis we deduce that
	$\delta_U (\interpret \Ua {t_{P,P'}}, \interpret \Ua {t_{Q,Q'}}, a) = \delta_U ((P,P'), (Q,Q'), a)$
	And by definition of $(T,T')$, $\delta_U ((P,P'), (Q,Q'), a) = (T,T')$.
	\ref{lem:prop3} is then verified.

	By definition, $T = \delta_A(P,Q,(a,*))$. Since by the induction hypothesis $P \subseteq \{ \delta_A (t_{P,P'},X) : X \subseteq \Nodes {t_{P,P'}}\}$
	and $Q \subseteq \{ \delta_A (t_{Q,Q'},X) : X \subseteq \Nodes {t_{Q,Q'}}\}$  we have that
	$T = \delta_A(P,Q,(a,*)) \subseteq \{ \delta_A (t_{T,T'},X) : X \subseteq \Nodes {t_{T,T'}}\}$. We have proven \ref{lem:prop1}.

	We will prove \ref{lem:prop2} by case distinction.
	Let $X \subseteq \Nodes {t_{P,P'}}$ such that $\forall \sigma \in \Aut (t_{T,T'}), \sigma(X) = X$, we introduce the
	sets $X_1 = X \cap \Nodes {t_{P,P'}}$ and $X_2 = X \cap \Nodes {t_{Q,Q'}}$.
	\begin{itemize}
		\item Lets suppose $P = Q$ and $P' = Q'$, in this case $t_{P,P'} \cong t_{Q,Q'}$. \todo{explain that it's because interpret is a function}
		      Let $\sigma$ be the automorphism over $\Nodes{T,T'}$ that swaps  $t_{P,P'}$ and $t_{Q,Q'}$.
		      We have that $\sigma (X) = X$. Since $\delta(X) = X$, $\delta$ must map $X_1$ to $X_2$, and the same is true for
		      $X_2$. So we have that $X_1 = X_2$ which means that $\delta(X_1) = X_1$. By construction we have that $p := \delta_A(t_{P,P'}, X_1) =  \delta_A(t_{Q,Q'}, X_2)$.
		      Using the induction hypothesis, we find that $p \in P'$ \todo{detail this}. So
		      $\delta_A (t_{T,T'}, X) = \delta_A(p,p,(a, X(\treeroot))) \in T'$. \todo{define $X(\treeroot)$.}

		\item Lets suppose $P' \neq Q'$ or $P \neq Q$, then $T' = \deltauu (P',Q',a) = \delta_a(P',Q',(a,*))$. We have to prove that
		      $\{ \delta_A (t_{T,T'},X) : \forall \sigma \in \Aut(t_{T,T'}), \sigma(X) = X\} \subseteq T'$.
		      Let $\sigma \in \Aut(t_{T,T'})$. Since $t_{P,P'} \ncong t_{Q,Q'}$, $\sigma$ cannot swap $t_{P,P'}$ and
		      $t_{P,P'}$ \todo{explain why}. Since we have that $\sigma(X) = X$, then we deduce that $\sigma(X_1) = X_1$ and
		      $\sigma(X_2) = X_2$ \todo{more details ?}. Let $p := \delta_A (t_{P,P'}, X_1)$ and $q := \delta_A (t_{Q,Q'}, X_2)$.
		      Using the induction hypothesis we deduce that $p \in P'$ and $q \in Q'$ \todo{Like in the previous case detail this?}.
		      So $\delta_A (t_{T,T'}, X) = \delta_A(p,q,(a, X(\treeroot))) \in T'$.
	\end{itemize}
	We have proved the three properties.

	Lets prove that  $\phi(X)$ is not "uniformisable" by exhibiting that no $X$ verifying $t_{R,R'} \models \phi(X)$ is "definable".
	Let $X \in F \cap \{ \delta_A (t_{R,R'},X) : X \subset \Nodes {t_{R,R'}}\}$, the intersection is not empty thanks to \ref{lem:prop1}. \todo{more details}
	We also know that $R' \cap F = \emptyset$ we can the deduce that $\{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \cap F = \emptyset$
	thanks to \ref{lem:prop2}. So we know that $X \notin \{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \cap F = \emptyset$ which means that no
	$X$ satisfying $t_{P,P'} \models \phi(X)$ is "definable". We deduce that $\phi(X)$ is not "uniformisable".
\end{proof}

\section{Conclusion}

\bibliographystyle{plainurl}
\bibliography{tre-uniformisation}

\end{document}
