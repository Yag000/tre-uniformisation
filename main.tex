\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{thmtools}
\usepackage{stmaryrd}

\usepackage{tikz}
\usetikzlibrary{arrows.meta,automata,positioning,calc,trees}
\usepackage{tikz-cd}
\usepackage{graphicx}

\usepackage{caption}

\usepackage{hyperref}

\usepackage{color}
\usepackage{xcolor}

\usepackage[hyperref]{knowledge}
\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}

\input{macros}
\input{tre-uniformisation.kl}


\title{Decidability of MSO Uniformisation on Finite Trees}

\author{Thomas Colcombet}
	{CNRS, IRIF, Universit\'e Paris Diderot, France}
	{thomas.colcombet@irif.fr}
	{https://orcid.org/0000-0001-6529-6963}
	{}

\author{Yago Iglesias Vázquez}{Universit\'e Paris Diderot, France}{me@yagoiglesias.fr}{}{}
\nolinenumbers


\authorrunning{T. Colcombet, Y. Iglesias Vázquez} 

\Copyright{Thomas Colcombet, Yago Iglesias Vázquez} 

\ccsdesc[500]{Theory of computation~Finite Model Theory}
\ccsdesc[500]{Theory of computation~Algebraic language theory}
\ccsdesc[500]{Theory of computation~Regular languages}

\keywords{MSO, uniformisation, finite state automata, trees} 

\category{Rapport de stage} 

\relatedversion{} 

\begin{document}

\maketitle

\begin{abstract}
	We study "uniformisation" for "MSO formulas" over "finite binary trees". A formula $\psi(X)$ "uniformises" $\phi(X)$
	if it selects at most one witness $X$ and, whenever $\phi$ has a witness, $\psi$ picks one. We show that,
	using symmetry-preserving automata ("order-insensitive" automata), it is decidable whether a
	given $\phi$ admits such a "uniformiser", and in the positive case, we effectively construct $\psi$. Our procedure translates $\phi$ into
	an "order-insensitive" "deterministic bottom-up tree automaton", checks whether that "automaton@DBUA" "accepts" every "tree", and, when
	it does, extracts from its "transition relation" an "MSO" formula that uniformly selects a witness. This reduces "MSO" "uniformisation"
	on finite "trees" to a simple "automata universality" test and a formula extraction step.
\end{abstract}

\tableofcontents
\todo{remove table of contents}
\todo{change knowledge mode}
\todo{an vs a}
\todo{satisfiable and model}
\todo{pay attention to nodes t}
\todo{knowledge all the *}
\todo{remove capital letter on definition parenthesis}
\newpage
\section{Introduction}

"Monadic second‐order" ("MSO") logic is a well-studied fragment of second-order logic with wide-ranging applications in graph theory, automata theory, and formal verification.
In particular, its deep connection with automata theory has been extensively explored. It is well known that MSO over finite words is equivalent in expressive power to
finite-state automata~\cite{Buchi60}.

This correspondence extends beyond words: automata can also be defined to run on "trees". Over finite "trees", MSO logic remains equivalent in expressive power to finite-state
tree automata~\cite{TW68, Don70}. This connection enables the use of automata-theoretic techniques to reason about "trees", one of the most fundamental and widely studied data
structures.

A classical challenge in this context is the \emph{uniformisation problem}: given an MSO formula $\phi(X)$ that asserts the existence of a set $X$ satisfying a certain property,
is it possible to define another MSO formula $\psi(Y)$ that selects \emph{at most one} such set for each tree, in a way that agrees with $\phi$ whenever it is satisfiable? We
formalize this notion in \Cref{sec:uniformisation}.

This problem has been studied in various settings. A comprehensive survey is provided in~\cite{Cara15}. Positive results are known for infinite words, where every MSO-definable
relation admits an MSO-definable uniformising function~\cite{Siefkes1975, Choffrut1999, Rabin07}. In contrast, uniformisation is not possible in general for infinite binary
trees~\cite{GS83}.
In this work, we study MSO uniformisation over a different class of structures: \emph{finite, labeled binary trees}.
All of the technical work is performed using only automata that preserve structural symmetry,
\ie they are unable to distinguish between left and right "subtrees".

The central question addressed in this paper is:

\begin{problem}[The ""uniformisation"" problem]\label{prob:uniformisation-problem}
\AP Given an MSO formula $\phi(X)$, does there exist a "uniformiser" $\psi(X)$?
\end{problem}

Our main result, \Cref{theorem:main}, is that this question is \emph{decidable}, and in the positive case, a "uniformiser" $\psi$ can be effectively constructed. Concretely, we translate $\phi$ into a
"deterministic bottom-up tree automaton" whose "transition map" is "order-insensitive" (\ie closed under sibling swaps). We then perform a "universality" check on this
automaton—does it accept every tree?—and, when it does, we extract from its transitions an MSO formula that uniformly selects a witness.

This paper makes three main contributions:
\begin{itemize}
	\item It establishes the classical equivalence between "monadic second-order logic" and "automata@NBUA" using "order-insensitive" "automata@NBUA", \Cref{thm:MSO-NBUA},
	\item It demonstrates the equivalence between "MSO uniformisation", "definability", and "automorphism" invariance, \Cref{lem:main-result},
	\item It extends the decidability of "MSO uniformisation" to "finite binary trees", \Cref{theorem:main}.
\end{itemize}


\paragraph*{Structure of the paper.} The remainder of the paper is structured as follows:
\Cref{sec:definitions} introduces the necessary definitions, notations and classical results on "trees", "automata@DBUA", and "MSO logic", with an emphasis on the "order-insensitive"
variant of tree automata.
In \Cref{sec:uniformisation}, we define the uniformisation problem and present our main result, showing that it is decidable for finite binary trees.
We conclude in \Cref{sec:conclusion} with a discussion of the implications of our results and potential future work.

\section{Definitions} \label{sec:definitions}

In this section, we review classical concepts related to trees, automata, and logic.
\Cref{sec:trees} establishes our notation for trees.
\Cref{sec:automata} provides a brief overview of bottom-up tree automata.
\Cref{sec:OrderAutomata} introduces an order-insensitive variant of these automata, and
\Cref{sec:UniversalityAutomata} defines a corresponding universality test.
Finally, \Cref{sec:MSO} describes how to translate "MSO formulas" into automata while preserving order insensitivity.N
\subsection{Trees}\label{sec:trees}

This first subsection contains the definition of the "trees" we are working with. Other equivalent definitions of "trees" and
automata are possible~\cite{Thomas1997, tata}, but we have chosen this one because it is more intuitive, without adding much complexity to the proofs.

\begin{definition}["Tree"]
	\AP A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$;
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are "trees".
	\end{itemize}
	We call the ""root"" of a "tree" the first node in its definition.
	The set of all "trees" over $\Sigma$ is denoted $\intro* \tree_{\Sigma}$.
	A subset of $\tree_{\Sigma}$ is called a ""tree language"" (or "language" for short).
\end{definition}

\begin{figure}[h]
	\centering

	\begin{tikzpicture}[
			level distance=1cm,
			sibling distance=1.5cm,
			every node/.style = {draw, circle}
		]

		\node {a}
		child { node {b} }
		child { node {c}
				child { node {d} }
				child { node {e} }
			};

	\end{tikzpicture}

	\caption{Concrete tree corresponding to $a(b, c(d, e))$.}
\end{figure}

\AP This recursive structure induces a natural notion of position within a "tree". We now define the set of ""nodes"",
represented as words over $\{0,1\}$ indicating a path from the root as
\[
	\intro* \Nodes t   =
	\begin{cases}
		\varepsilon                             & \text{if } t = a         \\
		\varepsilon \cup \setdef {0u} {u \in \Nodes {t'}}
		\cup \setdef {1u} {u \in \Nodes {t''} } & \text{if } t = a(t',t'')
	\end{cases}
\]

\begin{example}
	Let $ t := a(b, c(d, e)) $. We compute:
	\[
		\Nodes b  = \{\varepsilon\}, \quad \Nodes {c(d, e)} = \{\varepsilon, 0, 1\}
	\]
	\[
		\Nodes t = \{\varepsilon\} \cup \{0\} \cup \{1, 10, 11\} = \{\varepsilon, 0, 1, 10, 11\}
	\]
\end{example}

Among the "nodes", some are distinguished as "leaves", "nodes" without children.
\AP The ""leaves"" of a "tree" $t$ are defined as follows:
\[
	\intro* \Leaves t = \begin{cases}
		\varepsilon                              & \text{if } t = a         \\
		\setdef {0u} {u \in \Leaves {t'}}
		\cup \setdef {1u} {u \in \Leaves {t''} } & \text{if } t = a(t',t'')
	\end{cases}
\]

\AP We can see that $\Leaves t \subseteq \Nodes t $ and we call ""internal nodes"" the set $\Nodes t \cap \Leaves t$


Each "node" in a "tree" carries a symbol from the alphabet.
\AP Given a "tree" $t$ and a "node"$n$, we can access the ""label"" of the "node" $n$
thanks to the function $\intro* \tlabel t {\cdot}$ :
\[
	\tlabel t n =   \begin{cases}
		a               & \text{if } t = a \text{ and } n = \varepsilon         \\
		a               & \text{if } t = a(t',t'') \text{ and } n = \varepsilon \\
		\tlabel {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m          \\
		\tlabel {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
	\end{cases}
\]

We often need to refer to the "subtree" rooted at a particular "node".
\AP We introduce the notation $\intro* \subtree t n$ to refer to the ""subtrees""
of $t$ rooted at the node $n$. This can be computed as follows:
\[
	\subtree t n =   \begin{cases}
		t                & \text{if }  n = \varepsilon                  \\
		\subtree {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m \\
		\subtree {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
	\end{cases}
\]

The "ancestor" relation captures the natural hierarchical structure of a "tree": a "node" $x$ is an "ancestor"
of a "node" $y$ if $y$ is located in the "subtree" rooted at $x$.

\begin{definition}
	\AP Let $t$ be a "tree" and $x, y \in \Nodes t $. We define the ""ancestor"" relation as:
	\[
		x \intro* \ancestor y \tiff \exists z \in \Nodes t ,\, y = xz
	\]
\end{definition}

\begin{remark}
	Note that this order does not depend on the left or right position of the children, \ie it preserves
	"order-insensitivity", this will be explored in the following sections.
\end{remark}


\subsection{Automata over trees}\label{sec:automata}

In this subsection we aim to define the basics of tree automata in a comprehensive way, adding as much detail as possible to the proofs. For reference,
one can look at more advanced book on this topic \cite{tata,Thomas1997,bookautomata}.

In classical automata theory, we analyze deterministic finite automaton (DFA), wich assign a unique state to each prefix of
a word, updating this state at each step using a transition function, ussualy reading the input from left to right.

A "deterministic bottom-up tree automaton" ("DBUA") generalizes this idea to "trees": instead of reading a linear word, it reads a
a "tree" where each "node" carries a symbol from a fixed alphabet. Rather than scanning from left to right, it proceeds
bottom-up, computing "states" at each "node" by combining the states of its children :
the automaton aggregates the information from those "subtrees" to assign a "state" to the parent.

The idea is to recursively assign a "state" to each "node" of the "tree":
\begin{itemize}
	\item At the "leaves", the "state" is determined directly from the symbol via a function $\init$, just as a DFA starts in a particular initial state.
	\item A DFA transitions based on the current letter and the state reached by the previous letters.
	      When a "NBUA" reaches an "internal node", it transitions based on the "states" reached by its children and the "label" associated to the "node".
	\item Finally, the "state" assigned to the "root" tells us whether the whole "tree" is "accepted",
	      depending on whether it belongs to a set of "final states".
\end{itemize}

We now state the formal definitions.

\begin{definition}
	\AP A ""deterministic bottom-up tree automaton"" (\reintro*"DBUA") is a tuple $(\Sigma, Q, \init, \deltaA, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		      \itemAP $Q$ is a finite set of ""states"".
		      \itemAP $\intro*\init : \Sigma \to Q$ is a function that initializes the states of the "leaves".
		      \itemAP $\intro*\deltaA : Q \times Q \times \Sigma \to Q$ is the ""transition map"".
		      \itemAP $F \subseteq Q$ is the set of ""final states"".
	\end{itemize}
\end{definition}

\begin{definition}[Interpretation of an automaton]
	\AP The ""interpretation"" of a "DBUA" $A = (\Sigma, Q, \init, \deltaA, F)$  over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\intro* \interpret A ~: \tree_{\Sigma} &\to& Q \\
		a &\mapsto& \init_a \\
		a(t,t') &\mapsto& \deltaA_a (\interpret A t, \interpret A {t'})
	\end{eqnarray*}

	We say that $A$ ""accepts"" a "tree" $t$ if $\interpret A t \in F$.

	We will sometimes use the notation $\deltaA(t)$ for the "interpretation" of $A$ over the "tree" $t$.
\end{definition}

\begin{example}[Trees with at most one leaf]\label{ex:count-leaves}
	We define a "DBUA" $A = (\Sigma, Q, \init, \deltaA, F)$ that "accepts" exactly the "trees" with at most one "leaf". Let:
	\begin{itemize}
		\item $Q = \{0,1,2\}$, where $q=0$ means \textit{no leaves}, $q=1$ means \textit{exactly one leaf},
		      and $q=2$ means \textit{more than one leaf}.
		\item $F = \{0,1\}$.
		\item For all $a \in \Sigma$, we define $\init_a = 1$.
		\item The "transition function" is defined by:
		      \[
			      \deltaA_a(q_1, q_2) = \min(q_1 + q_2, 2)
		      \]
	\end{itemize}

	Intuitively, this automaton counts the number of "leaves" in the "tree", but caps the count at $2$ to detect when the number exceeds $1$.
	\Cref{fig:count-leaves} illustrates the execution of this automaton over a particular input.
\end{example}


\begin{figure}[h]\label{fig:count-leaves}
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			sibling distance=1.3cm,
			every node/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			treenode/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			scale=1, transform shape,
			state/.style={blue}
		]

		\node (t1) at (0,0) {a}
		child {node (t1b1) {b}}
		child {node (t1a2) {a}
				child {node (t1b3) {b}}
				child {node (t1b4) {b}}};

		\node at (2.2, -1) {$\Rightarrow$};

		\node (t2) at (4.5,0) {a}
		child {node[state ](t2b1) {1}}
		child {node (t2a2) {a}
				child {node[state] (t2s2) {1}}
				child {node[state] (t2s3) {1}}};

		\node at (6.7, -1) {$\Rightarrow$};

		\node (t3) at (9,0) {a}
		child {node[state] (t3s4) {1}}
		child {node[state] (t3a2) {2}};

		\node at (11.2, -1) {$\Rightarrow$};

		\node[state] (t4) at (13.5,0) {2};

	\end{tikzpicture}
	\caption{Execution of the automaton of \Cref{ex:count-leaves} over the input $a(b,a(b,b))$}
\end{figure}


In the same way that we can define a non-deterministic automaton over strings, the same can be done for
tree automata using the same techniques. We will define them and give basic definitions on how to use them.

\begin{definition}
	\AP A ""non-deterministic bottom-up tree automaton"" (\reintro*"NBUA") is defined as a tuple
	$(\Sigma, Q, \Init, \DeltaA, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of "states".
		      \itemAP $\intro*\Init \subseteq \Sigma \times Q$ correspond to the possible states of the "leaves".
		      \itemAP $\intro*\DeltaA \subseteq Q \times Q \times \Sigma \times Q$ is the ""transition relation"".
		\item $F \subseteq Q$ is the set of "final states".
	\end{itemize}
\end{definition}

\begin{definition}[Run of an automaton]
	\AP A ""run"" $\intro* \exec$ of a "NBUA" $A$ over a "tree" $t$ is :

	\begin{eqnarray*}
		\exec : \Nodes t  &\to& Q \\
		(\tlabel t b,  \exec (n) ) \in \Init &\text{ if }& n \in \Leaves t \\
		(\exec (n0), \exec (n1), \tlabel t n, \exec (n)) \in \DeltaA &\text{ if }& n \in \Nodes t \setminus \Leaves t
	\end{eqnarray*}

	We say that $\exec$ is "acceptant" if $\exec (\varepsilon) \in F$ and $A$ "accepts" $t$ if
	$F \cap \setdef {\rho(\varepsilon)} {\text{$\rho$ "run" of~$A$ over~$t$}} \neq \emptyset$
\end{definition}


\begin{definition}[Language of an automaton]
	\AP Let $A$ be a "NBUA". Its ""associated language"" is defined as:
	\[\intro* \lang A = \setdef {t \in \tree_{\Sigma}} {\text{exists $\rho$ a "accepting" "run" of $A$ over $t$}} \]
\end{definition}


We can easily see that "DBUA" are a particular case of "NBUA", just like in the classic theory.

\begin{remark}
	Every "DBUA" $A = (\Sigma, Q, \init, \deltaA, F)$ can be seen as a special case of a "NBUA"
	$A' = (\Sigma, Q, \Init, \DeltaA, F)$ where:
	\begin{itemize}
		\item $\Init = \setdef{(a, \init_a)}{a \in \Sigma}$,
		\item $\DeltaA = \setdef{(q_1, q_2, a, \deltaA_a(q_1, q_2))}{q_1, q_2 \in Q, a \in \Sigma}$.
	\end{itemize}

	In this case, $A'$ has exactly one possible "run" on each "tree" :

	\begin{eqnarray*}
		\exec : \Nodes t  &\to & Q \\
		n  &\mapsto& \init_{\tlabel t n} \text{ if } n \in \Leaves t \\
		n  &\mapsto& \deltaA_{\tlabel t n}(\exec (n0), \exec (n1)) \text{ if } n \in \Nodes t  \setminus \Leaves t
	\end{eqnarray*}
\end{remark}


The following lemma shows the equivalence of both definitions.

\begin{lemma}
	Let $A$ be a "DBUA",
	\[ \lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A t \in F} \]
\end{lemma}

\begin{proof}
	We will prove by induction on a "tree"~$t$ that (a) there exists a "run" of~$A$ over~$t$, and (b) for all "runs"~$\exec$ of $A$ over $t$, $\interpret A t = \exec (\varepsilon)$.
	We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$. Let $\rho$ be defined by $\rho(\varepsilon)=\init_a$, then $\rho$ is a "run" of~$A$ over~$t$. We have proved (a).
		      Consider now some "run" $\rho$ of $A$ over~$t$. We have $\rho(\varepsilon)=\init_a=\interpret A a=\interpret A t$. We have proved  (b).

		\item If $t = a(t',t'')$. By induction hypothesis (a), there exists "runs"~$\rho'$ and $\rho''$ on~$t'$ and $t''$ respectively.
		      Let~$\rho$ be defined by $\rho(\varepsilon)=\deltaA_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon))$,
		      $\rho(0u)=\rho'(u)$ for all $u\in\Nodes{t'}$ and $\rho(1u)=\rho''(u)$ for all~$u\in \Nodes{t''}$. Then $\rho$ is a "run" of~$A$ over $t$. We have proved (a).

		      Consider now some "run" $\rho$ of $A$ over $t$. Let~$\rho'(u)=\rho(0u)$ for all $u \in \Nodes {t'}$ and $\rho''(u)=\rho(0u)$ for all $u \in \Nodes {t''}$.
		      Then $\rho'$ is a "run" of~$A$ over $t'$ and $\rho''$ over $t''$. By induction hypothesis (b) twice, we know that $\rho'(\varepsilon)=\interpret A {t'}$ and $\rho''(\varepsilon)=\interpret A {t''}$.
		      We have now $\rho(\varepsilon) = \deltaA_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon)) = \deltaA_{t(\varepsilon)}(\interpret A {t'},\interpret A {t''}) = \interpret A t$. We have proved (b).
	\end{itemize}
\end{proof}


We aim now to show that, like in the classical theory, both "non-deterministic automata" and "deterministic@automata" ones have the same expressiveness power.
Since "DBUA" is a particular case of "NBUA" it suffices to show that each "language" accepted by an "NBUA" can also be accepted by a "DBUA".

\begin{definition}
	\AP Let $A = \NBUA$ be a "NBUA", we define the ""power set automaton"" of $A$, noted $\intro* \Det A$, as
	$\Det A = (\Sigma, \parts Q, \init, \deltaA, F')$ where:

	\begin{itemize}
		\item $\begin{aligned}[t]
				      \init      : \Sigma & \to \parts Q                              \\
				      a                   & \mapsto \setdef{q \in Q}{(a,q) \in \Init}
			      \end{aligned} $

		\item $\begin{aligned}[t]
				      \deltaA               : \parts Q \times \parts Q \times \Sigma & \to \parts Q                                                      \\
				      (X, Y, a)                                                      & \mapsto \setdef{q \in Q}{(x,y,a,q) \in \DeltaA, x \in X, y \in Y}
			      \end{aligned}$

		\item $F' = \setdef{X \in \parts Q}{X \cap F \neq \emptyset} \subseteq \parts Q$
	\end{itemize}
\end{definition}

\begin{theorem}
	For all $N = \NBUA$ an "NBUA", the "power set automaton" verifies that
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} \text{ and } \lang N = \lang {\Det N}
	\]
\end{theorem}

\begin{proof}
	We will first show that for all "tree" $t$,
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}\ .
	\]
	We will prove this property by induction over $t$. We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$, then
		      \begin{eqnarray*}
			      \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} &=&  \setdef {q \in Q} {(a,q) \in \Init} \\
			      &=& \interpret {\Det N} t\ .
		      \end{eqnarray*}
		\item If $t = a(t_1,t_2)$, then
		      by the induction hypothesis we know that
		      $\interpret {\Det N} {t_i} = q_i$ if and only if there exists a "run" over $t_i$ ending at $q_i$, for $i \in \set {1,2}$.

		      \begin{eqnarray*}
			      &&q \in \interpret {\Det N} t \\
			      &\text{if and only if}& q \in \deltaA_a (\interpret {\Det N} {t_1}, \interpret {\Det N} {t_2}) \\
			      &\text{if and only if}& q \in \setdef {q \in  Q} {(x_1,x_2,a,q) \in \DeltaA, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2}} \\
			      &\text{if and only if}& \exists x_1,x_2, (x_1,x_2,a,q) \in \DeltaA, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2} \\
			      &\text{if and only if}& \text{there exists a "run" over }  t_i  \text { ending at } x_i \text { for  } i \in \set {1,2} \text{ and } (x_1,x_2,a,q) \in \DeltaA\\
			      &\text{if and only if}& q \in \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}
		      \end{eqnarray*}
	\end{itemize}
	Then $ \interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}$.\\

	We must now show that $\Det N$ "accepts" $t$ if and only if $N$ "accepts" $t$.
	\begin{eqnarray*}
		N \text{ "accepts" } t &\tiff& F \cap \setdef {q \in Q} {(a,q) \in \Init} \neq \emptyset \\
		&\tiff&   F \cap  \interpret {\Det N} t \neq \emptyset \\
		&\tiff& \interpret {\Det N} t  \in F' \\
		&\tiff& {\Det N} \text{ "accepts" } t
	\end{eqnarray*}
	and so $\lang N = \lang {\Det N}$.
\end{proof}


\subsection{Order-insensitivity}\label{sec:OrderAutomata}

We will interest ourselves in a particular kind of tree automata: the ones that do not distinguish between left and right children.
That means that the state reached from the two children is the same if we swap them. These automata are
interesting because they respect the symmetries of "trees".

\begin{definition}
	\AP An "NBUA" of "transition relation"~$\DeltaA$ is ""order-insensitive"" if for all "transitions@@relation" $(p,q,a,r) \in \DeltaA$,
	$(q,p,a,r) \in \DeltaA$.
\end{definition}

\begin{remark}\label{def:order-insensitive}
	For a "DBUA" of "transition map"~$\deltaA$, it is "order-insensitive" if and only if
	$\deltaA_a (p,q) = \deltaA_a (q,p)$ for all "states"~$p,q$ and letter~$a$.
\end{remark}


\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			level 1/.style={sibling distance=1.5cm},
			every node/.style={draw, circle},
			baseline={(current bounding box.center)}
		]

		% Left Tree
		\node (root1) {$a$}
		child {node {$t_1$}}
		child {node {$t_2$}};

		% Right Tree
		\node (root2) at (6,0) {$a$}
		child {node {$t_2$}}
		child {node {$t_1$}};

		% State s
		\node[draw=blue] (s) at (3, -0.5) {$s$};

		% Arrows
		\draw[->, thick, draw=blue] (root1) to[out=0, in=180] node[draw=none, midway, below] {\(\deltaA_a\)} (s);
		\draw[->, thick, draw=blue] (root2) to[out=180, in=0] node[draw=none, midway, below] {\(\deltaA_a\)} (s);

	\end{tikzpicture}
	\caption{Illustration of "order-insensitivity" in a "DBUA" (see \Cref{def:order-insensitive}).
		Both trees yield the same state $s$ under the transition map $\deltaA_a$.}
	\label{fig:order-insensitivity}
\end{figure}



\begin{lemma}
	If $N = \NBUA$ a "NBUA" is "order-insensitive", then $\Det N$ is also "order-insensitive".
\end{lemma}

\begin{proof}
	\begin{eqnarray*}
		\deltaA_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \DeltaA, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \DeltaA, x \in X, y \in Y}  \reason {$N$ is "order-insensitive"} \\
		&=& \deltaA_a (Y,X)
	\end{eqnarray*}
\end{proof}

\subsection{Universality}\label{sec:UniversalityAutomata}

In this section, we define the "reachability set" of a "DBUA" and show that it can be used to decide the "universality" of the automaton.

\begin{definition}[""reachability set""]
	\AP Let $A = \DBUA$ a "DBUA", and let $\intro* \Reach A \subseteq Q$ be the smallest set such that:
	\begin{enumerate}
		\item $\init(a) \in \Reach A$ for all $a \in \Sigma$,
		\item $\deltaA(p, q, a) \in \Reach A$ for all $p, q \in \Reach A$ and $a \in \Sigma$.
	\end{enumerate}
\end{definition}

This set captures all "states" that can be reached by the automaton starting from the "leaves" and combining them using the transition function.
In particular, it represents the set of all "states" that can be reached when the automaton processes all possible "trees", motivating the following lemma.

\begin{lemma}
	Let $A$ be a "DBUA", then:
	\[
		\Reach A = \setdef {\interpret A t} {t \in \tree_\Sigma}.
	\]
\end{lemma}

\begin{proofI}
	We prove the equality by showing both inclusions.
	\begin{itemize}
		\item For the direction $\Reach A \subseteq \setdef {\interpret A t} {t \in \tree_\Sigma}$, we proceed by induction over the construction of elements in $\Reach A$:
		      \begin{itemize}
			      \item If $r = \init(a)$ for some $a \in \Sigma$, then the "tree" $a$ satisfies $\interpret A a = \init(a) = r$.
			      \item If $r = \deltaA(p, q, a)$ where $p, q \in \Reach A$, then by the induction hypothesis there exist
			            $t', t'' \in \tree_\Sigma$ such that $\interpret A {t'} = p$ and $\interpret A {t''} = q$. Then the "tree" $t = a(t', t'')$ satisfies $\interpret A t = r$.
		      \end{itemize}

		\item For the direction $\setdef {\interpret A t} {t \in \tree_\Sigma} \subseteq \Reach A$, we use structural induction on the "tree" $t$:
		      \begin{itemize}
			      \item If $t = a$, then $\interpret A a = \init(a) \in \Reach A$.
			      \item If $t = a(t', t'')$, then by the induction hypothesis $\interpret A {t'}, \interpret A {t''} \in \Reach A$, so
			            \[
				            \interpret A t = \deltaA(\interpret A {t'}, \interpret A {t''}, a) \in \Reach A.
			            \]
		      \end{itemize}
	\end{itemize}
\end{proofI}

\begin{definition}
	\AP Let $A$ be a "NBUA". We say that $A$ is ""universal"" if it "accepts" every "tree".
\end{definition}

Once we have defined the "reachability set", we can use it to decide whether an automaton is "universal". Intuitively, a "DBUA" is "universal" if
the only "states" it can reach are "final states". This is formalized in the following theorem.

\begin{theorem}
	A "DBUA" $A = \DBUA$ is "universal" if and only if $\Reach A \subseteq F$.
\end{theorem}

\begin{proofI}
	\begin{itemize}
		\item Suppose $A$ is "universal". Then for all $t \in \tree_\Sigma$, we have $\interpret A t \in F$ because $A$ "accepts" $t$.
		      Since $\Reach A = \setdef {\interpret A t} {t \in \tree_\Sigma}$, we conclude that $\Reach A \subseteq F$.

		\item Conversely, suppose $\Reach A \subseteq F$. For any "tree" $t \in \tree_\Sigma$, we have $\interpret A t \in \Reach A \subseteq F$.
		      Hence, $A$ "accepts" $t$ and is therefore "universal".
	\end{itemize}
\end{proofI}

\begin{coro}\label{coro:univeral-Reach}
	A saturation algorithm based on $\Reach A$ decides "universality".
\end{coro}

We have now defined an algorithm to decide whether a "DBUA" is "universal".
This result will be used in \Cref{sec:uniformisation} to decide "uniformisation".

\subsection{Monadic second-order logic}\label{sec:MSO}

\todo{Tak about the main result at some point, and do it better than right now}


\subsection{Monadic second-order logic on trees}

In this subsection, we introduce "monadic second-order logic" ("MSO") over "finite binary trees", and examine its relationship with
"non-deterministic bottom-up automata", in particular with "order-insensitive" "automata@NBUA".

Our objective is to show that "MSO" and "order-insensitive" "automata@NBUA" have the same expressive power. This will allow us to reason about properties
of "MSO" using automata theory techniques, which will be extensively used in \Cref{sec:uniformisation}.

\begin{definition}
	\AP Let $t \in \tree_{\Sigma}$. We define a ""model"" of $t$ as:
	\[
		\intro* \Model t := (\Nodes t, \ancestor , (a (x))_{a \in \Sigma})
	\]
	where each unary predicate $a(x)$ holds if and only if $\tlabel t x = a $.

	We write $t \models \phi$ to mean that the formula $\phi$ holds in the "model" $\Model t$.
\end{definition}

\begin{definition}
	\AP ""Monadic second-order logic"" (\reintro*"MSO") is the extension of the first-order logic with the following features:
	\begin{itemize}
		\item Variables can be either first-order (denoting "nodes") or second-order (denoting sets of "nodes").
		\item Quantification can be done over both first-order and second-order variables.
		\item The logic includes the usual logical connectives and quantifiers.
		      \itemAP The ""atomic formulas"" include:
		      \begin{itemize}
			      \item Equality between "nodes".
			      \item $x \in X$ means that the "node" $x$ belongs to the set $X$.
			      \item "Ancestor" relation: \( x \ancestor y \) means that \( x \) is an ancestor of \( y \).
			      \item Unary predicates for each symbol in the alphabet: \( a(x) \) means that the label of node \( x \) is \( a \).
		      \end{itemize}
	\end{itemize}
\end{definition}

\begin{definition}
	\AP We say that a language is ""MSO-definable"" if there exists an "MSO" formula \( \phi \) such that
	\[
		L = \setdef{t \in \tree_{\Sigma}}{t \models \phi}.
	\]
\end{definition}


We will discuss some examples of "MSO formulas".

\begin{example}
	\AP The formula
	\[
		\intro* \leaf(x) = \forall y,\, y \ancestor x
	\]
	expresses the fact that $x$ is a "leaf", a node without descendants.
\end{example}

\begin{example}
	\AP The formula
	\[
		\intro* \treeroot(x) = \forall y,\, x \ancestor y
	\]
	defines the "root" of the "tree", meaning a node that is an "ancestor" of every other node.
\end{example}

\begin{example}
	\AP The following formula expresses that $x$ and $y$ are the immediate children of a node $z$:
	\[
		\intro* \children(x,y,z) =
		x \neq y \land
		z \ancestor x \land  z \ancestor y \land
		\forall w
		\left( \left(
			z \ancestor w \land
				(w \ancestor x \lor w \ancestor  y) \right) \rightarrow (
			w = x \lor w = y
			)
		\right)
	\]
\end{example}


\todo{make this make sense please}
The proof follows the classical schema.

We start by showing that every "automaton@NBUA" can be expressed as a formula. The proof itself is standard \cite{Buchi60, Thomas1997, bookautomata}.

We can now state the main result of this section, which establishes the equivalence between "order-insensitive" "NBUA" and "MSO formulas".

\begin{theorem}\label{thm:MSO-NBUA}
	A "language" $L \subseteq \tree_{\Sigma}$ is "MSO-definable" if and only if there exists an "order-insensitive" "NBUA" $A$ such that $\lang A = L$.
\end{theorem}


We now show how to simulate an "automaton@NBUA" by a formula. The idea is to encode the existence of a valid "run" of
the "automaton@NBUA" using second-order variables that assign "states" to "nodes".

\begin{lemma}
	If $A$ is an "order-insensitive" "NBUA", then there exists a "MSO" formula $\phi$ such that for all $t \in \tree_{\Sigma}$,
	\[
		t \models \phi \text{ if and only if } t \in \lang A.
	\]
\end{lemma}

\begin{proof}\label{lem:Aut-to-MSO}
	Let $A = \NBUA$ be an "order-insensitive" "NBUA", and let $k = \abs Q$ be the number of "states".
	\todo{write something up here and move the formula to an annex}
	\begin{align}
		\phi =\  & \exists X_0 \ldots \exists X_{k-1} \ \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \label{lem:AMSO1}                                                                                     \\
		         & \land\ \forall x \left( \bigwedge_{0 \leq i < j \leq k-1} \lnot (X_i(x) \land X_j(x)) \right) \label{lem:AMSO2}                                                                                \\
		         & \land\ \forall x \left( \leaf(x) \rightarrow \bigvee_{(a,i) \in \Init} X_i(x) \right) \label{lem:AMSO3}                                                                                        \\
		         & \land\ \forall x\, \forall y\, \forall z \left(\children(x,y,z) \rightarrow \bigvee_{(p,q,a,r) \in \DeltaA} \left(X_p(x) \land X_q(y) \land a(z) \land X_r(z)\right) \right) \label{lem:AMSO4} \\
		         & \land\ \forall x \left( \treeroot(x) \rightarrow \bigvee_{q \in F} X_q(x) \right) \label{lem:AMSO5}
	\end{align}

	The sets $X_i$ encode the "run" of the automaton: $x \in X_i$ means that the "state" $i$ is assigned to the "node" $x$ in some valid accepting "run".

	The formula ensures:

	\begin{itemize}
		\item[\ref{lem:AMSO1}] Every "node" is assigned some "state".
		\item[\ref{lem:AMSO2}] No "node" is in more than one "state".
		\item[\ref{lem:AMSO3}] "Leaf" nodes are assigned an initial "state".
		\item[\ref{lem:AMSO4}] For each triple $(x,y,z)$ forming a parent and its two children,
		      there exists a transition in $\DeltaA$ from the children to the parent.
		\item[\ref{lem:AMSO5}] The "root" is labeled with a final "state".
	\end{itemize}

	Therefore, the formula defines the same "language" as the automaton:
	\[
		t \models \phi \iff t \in \lang A.
	\]
\end{proof}

We now turn to the other direction. Our goal is to show that for every "MSO" formula over finite binary "trees",
there exists an equivalent "order-insensitive" "non-deterministic bottom-up automaton".

The construction proceeds by induction on the structure of "formulas", using standard constructions for closure and the "atomic formulas".
Throughout, we ensure that the resulting automata remain "order-insensitive".

We begin with basic closure properties of such automata.

\begin{lemma}[Intersection]\label{lem:intersection}
	Let $A_1 = (\Sigma, Q_1, I_1, \DeltaA_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \DeltaA_2, F_2)$ be two "order-insensitive" "NBUAs". Then the product automaton
	\[
		A_3 = (\Sigma, Q_1 \times Q_2, I_1 \times I_2, \DeltaA, F_1 \times F_2),
	\]
	where
	\[
		\DeltaA = \left\{ ((q_1,q_2), (p_1,p_2), (a_1,a_2), (r_1,r_2)) \,\middle|\, (q_1,p_1,a_1,r_1) \in \DeltaA_1,\ (q_2,p_2,a_2,r_2) \in \DeltaA_2 \right\},
	\]
	is "order-insensitive", and satisfies $\lang{A_3} = \lang{A_1} \cap \lang{A_2}$.
\end{lemma}

\begin{lemma}[Union]\label{lem:union}
	Let $A_1 = (\Sigma, Q_1, I_1, \DeltaA_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \DeltaA_2, F_2)$ be two "order-insensitive" "NBUAs". Then the disjoint union
	\[
		A_3 = (\Sigma, Q_1 \uplus Q_2, I_1 \uplus I_2, \DeltaA_1 \uplus \DeltaA_2, F_1 \uplus F_2)
	\]
	is also "order-insensitive", and it accepts precisely the union of the two languages: $\lang{A_3} = \lang{A_1} \cup \lang{A_2}$.
\end{lemma}

\begin{lemma}[Complement]\label{lem:complement}
	Given an "order-insensitive" "NBUA" $A = (\Sigma, Q, \Init, \DeltaA, F)$, the automaton
	\[
		A' = (\Sigma, Q, \Init, \DeltaA, Q \setminus F)
	\]
	is also "order-insensitive", and recognizes the complement of $A$: $\lang{A'} = \lang{A}^\complement$.
\end{lemma}

We now turn to "atomic formulas". These are handled by explicitly designed automata over expanded alphabets that encode variable assignments.
We will only treat the ones that are relevant for our purposes, namely the atomic predicates $a(x)$ and $x \ancestor y$.

\todo{explain expanded alphabets and annotated trees}
\todo{define $X(\treeroot)$.}

In order to model variables we use "annotated trees", where each "node" is annotated with a bit vector representing the assignment of variables.
In this case, we will use the alphabet $\Sigma \times \{0,1\}^n$, where $n$ is the number of free variables in the formula.

\begin{example}
	The following tree corresponds to the "tree" $a(b,c(d,e))$ with two free variables, where the first variable is assigned to the "root" and the second to the "leaf"
	with label $e$:
	\[
		\begin{tikzpicture}[level distance=1.7cm,
				every node/.style={draw, circle, minimum size=5mm},
				level 1/.style={sibling distance=2cm},
				level 2/.style={sibling distance=1.6cm}]
			\node {(a,1,0)}
			child { node {(b,0,0)}}
			child { node {(c,0,0)}
					child {node {(d,0,0)}}
					child {node {(e,0,1)}} };
		\end{tikzpicture}
	\]

\end{example}

\begin{definition}["annotated tree"]
	Given a set of "nodes" $X$ and a "tree" t, we define an ""annotated tree"" as the pair $(t, X)$. This pair
	corresponds to a new "tree", where each "label" of a "node" is a pair consisting of the original "label" and a bit indicating whether the "node" belongs to the set $X$.

	We will use the notation $\intro*\bit X n $, where $n$ is a "node" of the "tree", to denote the bit indicating whether $n$ belongs to the set $X$.
\end{definition}

\begin{example}
	Let $t$ be the "tree" $a(b,c(d,e))$, and let $X = \{\varepsilon,11\}$.
	Then $(t, X)$ corresponds to the "annotated tree" :
	\[
		\begin{tikzpicture}[level distance=1.5cm,
				every node/.style={draw, circle, minimum size=5mm},
				level 1/.style={sibling distance=2cm},
				level 2/.style={sibling distance=1.5cm}]
			\node {(a,1)}
			child { node {(b,0)}}
			child { node {(c,1)}
					child {node {(d,0)}}
					child {node {(e,0)}} };
		\end{tikzpicture}
	\]
\end{example}



\todo{maybe move these automata to the annex}

\begin{lemma}\label{lem:atomic-a}
	Let $a \in \Sigma$. Over the alphabet $\Sigma \times \{0,1\}$, there exists an "order-insensitive" automaton deciding
	the atomic predicate $a(x)$, where $x$ is a free first-order variable. Define:
	\[
		A = (\Sigma \times \{0,1\}, \{\text{Yes}, \text{No}\}, \init, \deltaA, \text{Yes}),
	\]
	where:
	\begin{itemize}
		\item
		      \[
			      \init(a,1) = \text{Yes}, \quad \init(\_,\_) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \deltaA(\_, \_, (a,1))            & = \text{Yes} \\
				      \deltaA(\text{No}, \text{No}, \_) & = \text{No}  \\
				      \deltaA(\_, \_, \_)               & = \text{Yes}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}\label{lem:atomic-ancestor}
	There exists an "order-insensitive" automaton over $\Sigma \times \{0,1\}^2$ that decides the formula $x \ancestor y$. We define:
	\[
		A = (\Sigma \times \{0,1\}^2, \{\text{Yes}, \text{No}, \text{FoundY}\}, \init, \deltaA, \text{Yes}),
	\]
	with the following behavior:
	\begin{itemize}
		\item
		      \[
			      \init(\_,\_,1) = \text{FoundY}, \quad \init(\_,\_,0) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \deltaA(\text{FoundY}, \_, (\_,1,0)) & = \text{Yes}    \\
				      \deltaA(\_, \text{FoundY}, (\_,1,0)) & = \text{Yes}    \\
				      \deltaA(\text{FoundY}, \_, (\_,0,0)) & = \text{FoundY} \\
				      \deltaA(\_, \text{FoundY}, (\_,0,0)) & = \text{FoundY} \\
				      \deltaA(\text{Yes}, \_, \_)          & = \text{Yes}    \\
				      \deltaA(\_, \text{Yes}, \_)          & = \text{Yes}    \\
				      \deltaA(\_, \_, (\_,0,1))            & = \text{FoundY} \\
				      \deltaA(\_, \_, \_)                  & = \text{No}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}[from MSO to automata]\label{lem:MSO-to-aut}
	Let $\phi$ be an MSO formula. Then there exists an "order-insensitive" "NBUA" $A$ such that for every $t \in \tree_\Sigma$, we have:
	\[
		t \models \phi \quad \text{if and only if} \quad t \in \lang{A}.
	\]
\end{lemma}

\begin{proof}
	The construction proceeds by structural induction on $\phi$.

	Formulas such as $a(x)$ and $x \ancestor y$ are handled directly by the automata
	in \Cref{lem:atomic-a,lem:atomic-ancestor}, which operate over trees annotated with assignments to free variables.

	For conjunction and disjunction, we apply the induction hypothesis to obtain automata
	for the subformulas, then use the constructions from \Cref{lem:intersection,lem:union} to obtain an automaton for the whole expression.

	If $\phi = \lnot \psi$, then by the induction hypothesis we obtain an automaton for $\psi$. We apply
	\Cref{lem:complement} to obtain an automaton for $\phi$.

	Assume $\phi = \exists x.\psi(x)$, where $\psi$ has $n$ free variables and $x$ is the $n$-th one.

	By the induction hypothesis, we have an "order-insensitive" "DBUA" (since avery "NBUA" can be converted to a "DBUA")
	\[
		A = (\Sigma \times \{0,1\}^n, Q, \init, \deltaA, F)
	\]
	that accepts the language of $\psi(x)$, where we assume the input "trees" "annotated" with $n$ bits per "node" and the $n$-th bit indicates
	whether the node is assigned to $x$.

	We now construct an automaton that operates over $\Sigma \times \{0,1\}^{n-1}$, where $x$ is no longer explicitly assigned.
	Instead, we simulate all possible annotations for $x$, and accept if at least one such "annotation" makes $\psi(x)$ true.

	Define the new automaton:
	\[
		A' = (\Sigma \times \{0,1\}^{n-1}, \parts Q, \init', \deltaA', F')
	\]
	where:
	\begin{itemize}
		\item Initial state set:
		      \[
			      \init'(a, \vec{b}) = \setdef{ \init(a, \vec{b}, b')} {b' \in \{0,1\} }
		      \]
		      That is, we simulate both possibilities for the missing $x$-bit.
		\item "Transition map":
		      \[
			      \deltaA'(P, Q, (a, \vec{b})) = \setdef{ \deltaA(p, q, (a, \vec{b}, b'))} {p \in P,\ q \in Q,\ b' \in \{0,1\} }
		      \]
		      Again, for every guess of $x$’s value at this "node", we compute the next "state" as if that guess were part of the input.
		\item "Accepting states":
		      \[
			      F' = \setdef{ P \subseteq Q} {P \cap F \neq \emptyset }
		      \]
		      The automaton accepts if one of the runs under some assignment for $x$ ends in an "accepting state".
	\end{itemize}

	This automaton simulates all possible choices of a "node" for $x$, \ie, all possible  bit "annotations" for the $x$-variable.
	Since $A$ is "order-insensitive", and the construction treats all "nodes" symmetrically, $A'$ is also "order-insensitive".

	For $\phi = \exists X.\psi(X)$, the construction is similar. The automaton $A$ reads $n$-bit "annotations", with the last bit corresponding
	to the second-order variable $X$. We define $A'$ by again simulating all two options for each node (being in $X$ or not) and applying the same
	"power set construction".

	Each inductive case preserves "order-insensitivity", and constructs an "NBUA" for the given formula. Thus, by induction on the structure of $\phi$,
	we obtain the desired automaton.
\end{proof}


\section{Uniformisation}\label{sec:uniformisation}

In this section we are going to formally define what "uniformisation" is, give some intuition about it,
propose an algorithm that decides "uniformisation" on finite binary trees and prove its correctness and soundness.
The main result is \Cref{thm:uniformisability-decision}.

\subsection{Definitions and statement of the main theorem}

We begin by formalising the core concepts.

\begin{definition}\label{def:uniformiser}
	\AP A formula $\psi(X)$ is a ""uniformiser"" of a formula $\phi(X)$ if, for all "trees" $t$, the following hold:
	\begin{enumerate}
		\item There exists at most one set $X$ such that $t \models \psi(X)$.
		\item If there exists a set $X$ such that $t \models \phi(X)$, then there exists a set $Y$ such that $t \models \psi(Y) \land \phi(Y)$.
	\end{enumerate}
	\AP A formula $\phi(X)$ is said to be ""uniformisable"" if it admits a "uniformiser".
\end{definition}

\begin{remark}\label{remark:uniformisability}
	An equivalent way to express that $\phi(X)$ is "uniformisable" is that there exists an "MSO-formula" $\psi(x)$ such that, for all "trees" $t$:
	\[
		t \models \exists X.\, \phi(X) \quad \text{implies} \quad t \models \phi(\setdef{x}{t \models \psi(x)}).
	\]
	Note that here we use a set defined by comprehension, which is not in the syntax of plain "MSO logic".
	This is for commodity and can be easily translated into a syntactically correct equivalent statement.
\end{remark}

We can now state the main result of this work.
\begin{theorem} \label{thm:uniformisability-decision}\label{theorem:main}
	There exists an algorithm which, given an "MSO-formula" as input, decides whether it has a "uniformiser" over finite "unordered binary trees".
\end{theorem}

In fact, it is a consequence of a more precise result, \Cref{lemma:main}, that we state now, though all the definitions necessary have not yet been provided.
\begin{lemma}\label{lem:main-result}\label{lemma:main}
	For all "MSO-formulas" $\phi(X)$, the following statements are equivalent:
	\begin{enumerate}
		\item $\phi(X)$ is "uniformisable". \label{lem:main-result-1}
		\item For all "trees" $t$ that models $\phi(X)$ for some~$X$, $t$ models~$\phi(X)$ for some "definable"~$X$. \label{lem:main-result-2}
		\item For all "trees" $t$ that models $\phi(X)$ for some~$X$, $t$ models~$\phi(X)$ for some~$X$ invariant under the automorphisms of~$t$ (ie such that $\sigma(X) = X$ for all $\sigma \in \Aut(t)$). \label{lem:main-result-3}
		\item The "uniformiser automaton" of~$\phi(X)$ is "universal". \label{lem:main-result-4}
	\end{enumerate}
	As as consequence, "uniformisability@uniformisable" of "MSO" over trees is decidable.
\end{lemma}
In the rest of this section, we recall the definitions of "definable" sets and invariance under "automorphisms" from which we immediately get the implications from
\Cref{lem:main-result-1} to \Cref{lem:main-result-2}, and from \Cref{lem:main-result-2} to \Cref{lem:main-result-3}. The "uniformiser automaton"
is then defined in the next section, \kCref{uniformiser automaton}. The implication from \Cref{lem:main-result-3} to \Cref{lem:main-result-4} is then the subject of
\Cref{lemma:not-universal-implies-non-invariant} in \Cref{section:soundness} and the implication from~\Cref{lem:main-result-4} to \Cref{lem:main-result-1} is stated in
\Cref{lemma:universal-implies-uniformisable}, \Cref{section:correctness}.

\begin{definition}["definable set"]\label{def:definable}
	\AP Let $t$ be a "tree". A set $X \subseteq \Nodes t$ is said to be ""definable"" if there exists an
	"MSO" formula $\phi(x)$ such that $X = \setdef{x}{t \models \phi(x)}$.
\end{definition}

In particular, if $\phi(X)$ is "uniformisable", there exists a "uniformiser" $\psi(x)$ such that for all "trees" $t$,
we have that the set $X_d = \setdef{x}{t \models \psi(x)}$ is "definable" in $t$ and models $\phi(X_d)$ if $t$ models $\exists X.\, \phi(X)$,
see \Cref{remark:uniformisability}.
This proves the implication from \Cref{lem:main-result-1} to \Cref{lem:main-result-2} in \Cref{lemma:main}.

Another concept used in this section is the one of "automorphisms" of "trees".
\begin{definition}["automorphism"]\label{def:automorphism}
	\AP An ""automorphism"" of a "tree" $t$ is a bijection $\sigma : \Nodes t \to \Nodes t$ preserving the tree structure:
	if $u$ is a child of $v$, then $\sigma(u)$ is a child of $\sigma(v)$, and $\sigma$ preserves the labels of nodes.
	The group of all automorphisms of $t$ is denoted $\intro* \Aut(t)$.
\end{definition}

In other words, an "automorphism" is a symmetry of the "tree" that rearranges its nodes while preserving the ancestor relation and labels.
Let us illustrate this concept with an example.


\begin{example}
	We compare the automorphism groups of two binary trees.

	\begin{center}
		\begin{tabular}{cc}
			% First tree
			\begin{tikzpicture}[level distance=1.2cm,
					every node/.style={draw, circle, minimum size=7mm},
					level 1/.style={sibling distance=2cm},
					level 2/.style={sibling distance=1cm}]
				\node {r}
				child { node {a}
						child {node {b}}
						child {node {b}} }
				child { node {a}
						child {node {c}}
						child {node {c}} };
			\end{tikzpicture}
			                           &
			% Second tree
			\begin{tikzpicture}[level distance=1.2cm,
					every node/.style={draw, circle, minimum size=7mm},
					level 1/.style={sibling distance=2cm},
					level 2/.style={sibling distance=1cm}]
				\node {r}
				child { node {a} }
				child { node {a}
						child {node {b}}
						child {node {b}} };
			\end{tikzpicture}
			\\
			\textbf{Tree A: Symmetric} & \textbf{Tree B: Asymmetric}
		\end{tabular}
	\end{center}

	\textbf{Tree A} is a complete "binary tree" of height 2. In this case, there are 8 "automorphisms", corresponding to all possible ways of swapping left and right children at each level.

	\textbf{Tree B}, on the other hand, is asymmetric. The left child of the root is a "leaf", while the right child is an "internal node" with two children.
	Since these "subtrees" are not structurally the same, the only "automorphisms" are:
	\begin{itemize}
		\item the identity (doing nothing), and
		\item swapping the two children of the right "subtree".
	\end{itemize}
\end{example}



\begin{lemma}\label{lem:def-aut}
	If $X$ is "definable" in a "tree" $t$, then $\sigma(X) = X$ for all $\sigma \in \Aut(t)$ .
\end{lemma}
\begin{proof}[Idea of a proof]
	If $X$ is "definable", there exists an "MSO" formula $\phi(x)$ such that $X = \setdef{x}{t \models \phi(x)}$.
	We want to show that for all $\sigma \in \Aut(t)$ and all $x \in X$, we have $t \models \phi(\sigma(x))$.
	Since $\sigma$ is a bijection, this suffices to conclude $\sigma(X) = X$.

	The idea is that an MSO formula, by construction, cannot distinguish between "nodes" that are mapped to each other by "automorphisms":
	these transformations preserve the structure and labels of the "tree".

	The proof proceeds by induction on the structure of $\phi$. "Atomic formulas" are invariant under "automorphisms" by definition,
	since "automorphisms" preserve the tree structure and labeling. The logical connectives (conjunction, disjunction, negation)
	and quantifiers preserve this invariance, so the property holds inductively.

	Therefore, for all $x \in X$, we have $t \models \phi(x) \Rightarrow t \models \phi(\sigma(x))$, and hence $\sigma(x) \in X$. Thus, $\sigma(X) = X$.
\end{proof}

The implication from \Cref{lem:main-result-2} to \Cref{lem:main-result-3} in \Cref{lemma:main} is a direct consequence of \Cref{lem:def-aut}.

\subsection{The uniformiser automaton}

Let us fix a formula $\phi(X)$. At very high level, what we aim at is a procedure that would solve a statement of the form\footnote{This is an intuition, and not a valid formula of MSO.}:
\[
	(\exists X.\, \phi(X)) \rightarrow (\exists X.\, \phi(X) \text{ and $X$ is invariant under "automorphism"}).
\]
We aim to build an automaton that somehow accepts the "trees" for which this property holds.
This is the "uniformiser automaton" for the formula, that we describe below. We then show in \Cref{lemma:universal-implies-uniformisable} that if it is "universal",
then $\phi(X)$ is "uniformisable", and in \Cref{lemma:not-universal-implies-non-invariant} that if it is not "universal", then there exists a
"tree"~$t$ that models~$\phi(X)$ for some~$X$, but does not model~$\phi(X)$ for some~$X$ that would be invariant under the automorphisms of~$t$.
\begin{definition}["Uniformiser automaton"]
	\AP Let $\phi(X)$ be an "MSO" formula and $A = (\Sigma \times \{0,1\}, Q, \init, \deltaA, F)$ its "DBUA". The ""uniformiser automaton"" is defined as
	\[
		\intro* \Ua = (\Sigma, \parts{Q} \times \parts{Q}, \init_U, \deltau, F')
	\]
	where:
	\begin{itemize}
		\item $\init_U(a) = (\init(a,"*"), \init(a,"*"))$
		      \itemAP $\intro*\deltau((X,X'),(Y,Y'),a) = (\deltaA(X,Y,(a,*)), \deltauu(X',Y',a))$ with:
		      \[
			      \intro*\deltauu(X',Y',a) = \begin{cases}
				      \setdef{\deltaA(p,p,(a,b))}{p \in X', b \in \set{0,1}} & \text{if } X' = Y' \\
				      \deltaA(X',Y',(a,"*"))                                 & \text{otherwise}
			      \end{cases}
		      \]
		\item $F' = \setdef{(X,X')}{(X \cap F \neq \emptyset) \Rightarrow (X' \cap F \neq \emptyset)}$
	\end{itemize}
	\AP Using the notation $\deltaA(X,Y,(a,""*""))$ for $\bigcup_{b \in \set{0,1}} \deltaA(X,Y,(a,b))$, and $\init(a,\reintro{*})$ for $\bigcup_{b \in \set{0,1}} \init(a,b)$.
\end{definition}


Intuitively, $\Ua$ checks whether $\phi(X)$ has a witness, and attempts to reconstruct a "definable" one using symmetry constraints.
If no structural difference between left and right can be observed, the automaton forces them to behave identically, guaranteeing
"definability" by symmetry.

Each state of the "uniformiser automaton" is a pair of sets of states of the original automaton for $\phi$.
The first component represents a standard run of the original automaton (checking if the formula $\phi(X)$
is satisfiable), while the second component simulates a restricted run that is meant to capture a "definable" witness.
When both sides behave identically on a given "subtree", that is, when the shape and annotations of the tree do not allow
us to distinguish between them, the automaton enforces that they must transition identically, ensuring symmetry. This restriction
is what guarantees "definability": the selected witness must be invariant under all "automorphisms" of the "tree".

\begin{definition}["Uniformisability checking algorithm"]
	\AP Given an "MSO" formula $\phi(X)$ as an input, the ""uniformisability checking algorithm"" constructs the "uniformiser automaton" $\Ua$ for $\phi(X)$ and checks whether it is universal,
	using the algorithm from \Cref{coro:univeral-Reach}.
	If $\Ua$ is universal, then the algorithm returns 'yes', indicating that $\phi(X)$ is "uniformisable".
	Otherwise, it returns 'no', indicating that $\phi(X)$ is not "uniformisable".
\end{definition}

In the rest of this section, we will prove that this algorithm is correct and sound, leading to the main result of this article, \Cref{thm:uniformisability-decision}.

\subsection{Correctness}\label{section:correctness}

In this section, we prove the correctness of the "uniformisability checking algorithm", which is the
implication from \Cref{lem:main-result-4} to  \Cref{lem:main-result-1} in \Cref{lemma:main}.
This is what states the next lemma.

\begin{lemma}\label{lemma:universal-implies-uniformisable}
	Let $\phi(X)$ be an MSO formula, if the "uniformiser automaton" of $\phi$ is "universal" then $\phi$ is "uniformisable".
\end{lemma}
\begin{proof}
	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \deltaA, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$\Ua = (\Sigma, \parts Q \times \parts Q,\init', \deltaA', F')$ the "uniformiser automaton" of $\phi$ is universal.
	We need to exhibit a "uniformiser" for $\phi(X)$.

	\AP We first introduce a choice function $\intro*\choiceN : \parts Q \times \parts Q \times Q \times \Sigma \to Q \times Q \times \set{0,1}$
	that given $(X',Y',r,a)$ chooses a triple $(b,p,q)$ such that, if $r \in \deltauu(X',Y', a)$ then $\deltaA(p,q,(a,b)) = r$ where $p \in X', q \in Y'$
	and if $X' = Y'$ then $p = q$.
	We also introduce $\intro* \choiceL : Q \times \Sigma \to \set{0,1} $, which chooses
	$b$ such that $p = \init((a,b))$.
	Finally, we need to choose from a final state: $\intro* \choiceF : \parts Q \to  Q$ where
	$\choiceF (X) = q$ such that if $X \cap F \neq \emptyset$ then $q \in X \cap F$. If the premises are not satisfied in any of the cases, then
	these choice functions return an arbitrary value.

	\AP We define the set $X_U$ and the "run" $\intro*\rhou$  by induction on the depth of the node as follows:
	\begin{itemize}
		\item For the root, we define $\rhou(\varepsilon) = \choiceF(\deltauu(t))$.
		\item For all inner nodes $x$ with children $y$ and $z$. Let $(p,q,v)$ be $\choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), \rhou(x), \tlabel t x)$, we define
		      $\rhou(y)=p$, $\rhou(z)=q$, and $x \in X_U$ if and only if $b = 1$.
		\item For all "leaves" $x$, let $b$ be ~$b = \choiceL(p, \tlabel t x)$ we define $\rhou (x) = p$, where $x \in X_U$ if and only if $b = 1$.
	\end{itemize}

	We claim now that the $\rhou$ is well defined, unique, and a "run" of $A$ over $(t,X_U)$. The proof procedes by top-down induction.
	\begin{itemize}
		\item For $\varepsilon$, the "root" of $t$, we have that $\rhou(\varepsilon) = \choiceF(\deltauu(t))$, since $\choiceF$ is deterministic, $\rhou(\varepsilon)$ is unique.
		\item For the inner nodes $x$ with children $y$ and $z$, there exists $r \in Q$, such that $\rhou (x) = r$ by the induction hypothesis. Then,
		      since $\choiceN$ is deterministic, there exists a unique tuple $(p,q,b)$ such that
		      $(p,q,b) = \choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), r, \tlabel t x)$.
		      We have that $\rhou(y) = p$ and $\rhou(z) = q$, which verify that $\deltaA(p,q,(\tlabel t x,b)) = r$. We also have that $x \in X_U$ if and only if $b = 1$.
		      This is then a valid "run" of $A$ over $(t,X_U)$
		\item For a "leaf" $x$ of "label" $a$, by the induction hypothesis we have that $b = \choiceL(a, \rhou(x))$ which is well defined since $a \in \Sigma$ and unique.
		      We also have that $x \in X$ if and only if $b = 1$ and $\rho(x) = \init ((a,b))$.
	\end{itemize}
	The claim is proved. In particular, this run satisfies the restrictions of $\deltauu$ and it's a run over the second projection of $\Ua$.

	\AP We are now ready to define a formula $\intro*\unif (X)$ that witnesses that $\phi$ is "uniformisable".
	This formula simply states using the MSO-syntax the existence of the run $\rhou$ described above, \ie,
	\[  t \models \unif(X)  \tiff X=X_U \]

	\AP Given a set of "states" $P$, from \Cref{thm:MSO-NBUA} there exists a formula $\intro* \ustate_P(x)$ such that
	\[ t \models \ustate_P(x) \text{ if and only if } \deltauu(\subtree t x) = P .\]

	\todo{add explanation here !!!}

	Let $k = \abs Q$.
	\todo{maybe move to annex ?}
	\todo{change in set}
	We define 5 subformulas :

	\begin{eqnarray*}
		\AP \intro* \singleState (X_{p_1}, \ldots, X_{p_k})  &=& \forall x, \bigvee_{1 \leq i \leq k} X_{p_i} (x)\\
		&\land& \forall x, \bigwedge_{1 \leq i, j \leq k, i \neq j} \lnot(X_{p_i} (x) \land X_{p_j}(x))
	\end{eqnarray*}

	\begin{equation*}
		\AP \intro*	\rootNode (X_{p_1}, \ldots, X_{p_k})  = \forall x, \treeroot(x) \ra (\bigvee_{p_i \in \choose \deltauu(\varepsilon)} X_{p_i}(x))
	\end{equation*}

	\begin{equation*}
		\AP \intro* \inSet (X, x, b)  = (\bigwedge_{b = 1}  X(x)) \land (\bigwedge_{b = 0}  \lnot X(x))
	\end{equation*}

	\begin{equation*}
		\AP \intro* \leafNode (X_{p_1}, \ldots, X_{p_k})  = \forall x \left( \leaf(x) \rightarrow \bigvee_{\substack{(a, q) \in \init,\\ \choiceL(a,q) = b}} X_i(x) \land  \inSet (X,x,b)  \right)
	\end{equation*}
	\AP
	\begin{eqnarray*}
		\intro* \innerNodes (X_{p_1}, \ldots, X_{p_k}, X)  &=& \forall x \forall y, \forall z, \children (x,y,z) \ra \\
		&& \bigvee_{ \substack{(P',Q',a,R')\in \deltauu, \, r \in R', \\ \choiceN(P',Q',a,r) = (p,q,b)}} \Big( \ustate_{P'}(x) \land \ustate_{Q'}(y) \\
		&& \qquad \land \  X_p(x) \land X_q(y) \land a(z) \land X_r(z) \land  \inSet(X,x,b)\Big)
	\end{eqnarray*}


	We can now define $\unif(X)$:
	\begin{eqnarray*}
		\unif (X) &=& \exists X_{p_1}, \ldots, \exists X_{p_k}, \singleState (X_{p_1}, \ldots, X_{p_k}) \\
		&\land& \leafNode (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \rootNode (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \innerNodes (X_{p_1}, \ldots, X_{p_k}, X)
	\end{eqnarray*}
	$\unif(X)$ describes the run $\rhou$ over $(t,X_U)$ and has a unique solution, $X_U$.

	Let's show that $\unif(X)$ is a "uniformiser" for $\phi(X)$.
	If $\Ua$ is universal the we have that, whenever $\phi(X)$ has a solution for a tree $t$, then there exists an accepting "run" $\rho$ of $\Ua$ over $t$
	such that $\rho(\varepsilon) = (X,X')$ and such that $X \cap F \neq \emptyset$. Since the run is accepting $X' \cap F \neq \emptyset$, and we have that
	$\rhou$ is then well defined and $\unif(X)$ has a solution. Since $\rhou$ is a run of $A$, then we have that $X_U$ is also a solution of $\phi(X)$, so
	$\unif(X)$ is indeed a "uniformiser" for $\phi(X)$.

\end{proof}

\subsection{Soundness}\label{section:soundness}

In this section, we prove the soundness of the "uniformisability checking algorithm", by compleating the proof of \Cref{lem:main-result-3} to
\Cref{lem:main-result-4} in \Cref{lemma:main} by contraposition.
This chain of implications states that if $\phi(X)$ is "uniformisable", then the "uniformiser automaton" of $\phi(X)$ is "universal", \ie that the algorithm is sound.

\begin{lemma}\label{lemma:not-universal-implies-non-invariant}
	Let $\phi(X)$ be and MSO formula,
	if the "uniformiser automaton" of $\phi(X)$ is not  "universal",
	then there exists a "tree"~$t$ that models~$\phi(X)$ for some~$X$, but does not model~$\phi(X)$ for some~$X$
	that would be invariant under the automorphisms of~$t$.
\end{lemma}

\begin{proof} \todo{change : to $\mid$} \todo{knoledge all *}
	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \deltaA, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$\Ua = (\Sigma, \parts Q \times \parts Q,\init', \deltaA', F')$ the "uniformiser automaton" of $\phi$ is not universal.
	We will show that there exists a "tree" $t$ that models  $\phi(X)$ for a some $X$, but does not model $\phi(X)$ for
	some $X$ that is invariant under the automorphisms of $t$.

	Since $\Ua$ is not "universal", there exists $(R,R') \in \Reach \Ua$, such that $R \cap F \neq \emptyset$ and $R' \cap F = \emptyset$.
	We want to define a "tree" $t_{R,R'}$ such that
	\begin{enumerate}
		\item $R \subseteq \{ \deltaA_A (t_{R,R'},X) \mid X \subseteq \Nodes {t_{R,R'}}\}$ \label{lem:prop1}
		\item $\{ \deltaA_A (t_{R,R'},X) \mid \forall \sigma \in \Aut(t_{R,R'}), \sigma(X) = X\} \subseteq R'$\label{lem:prop2}
		\item $\interpret \Ua {t_{R,R'}} = (R,R')$\label{lem:prop3}
	\end{enumerate}

	We prove by induction that $(T,T') \in \Reach \Ua$ implies all of the three conditions.

	If $(T,T') = (\init(a,"*"), \init (a, "*"))$ for $a \in \Sigma$, then \Cref{lem:prop1} and \Cref{lem:prop3} are trivially satisfied and we have that
	$\Aut (a) = \{\text{id}\}$, so \Cref{lem:prop2} is also satisfied.

	If $(T,T') = \deltaA_{\Ua}((P,P'),(Q,Q'),a)$ for $a \in \Sigma$ and $P,P',Q,Q' \in \Reach \Ua$, then by the induction hypothesis there exists
	$t_{P,P'}$ and $t_{Q,Q'}$ that verify the hypothesis. We can construct $t_{T,T'} = a(t_{P,P'},t_{Q,Q'})$. Lets prove that it satisfies the
	three properties.

	Lets begin by proving \Cref{lem:prop3}.
	By definition of $\interpret \Ua {\cdot}$,
	$\interpret \Ua {t_{T,T'}} = \deltaA_{\Ua} (\interpret \Ua {t_{P,P'}}, \interpret \Ua {t_{Q,Q'}}, a)$.
	If we use \Cref{lem:prop3} of the induction hypothesis we deduce that
	$\deltaA_{\Ua} (\interpret \Ua {t_{P,P'}}, \interpret \Ua {t_{Q,Q'}}, a) = \deltaA_{\Ua} ((P,P'), (Q,Q'), a)$
	And by definition of $(T,T')$, $\deltaA_{\Ua} ((P,P'), (Q,Q'), a) = (T,T')$.
	\Cref{lem:prop3} is then verified.

	By definition, $T = \deltaA_A(P,Q,(a,"*"))$. Since by \Cref{lem:prop1} of the induction hypothesis $P \subseteq \{ \deltaA_A (t_{P,P'},X) \mid X \subseteq \Nodes {t_{P,P'}}\}$
	and $Q \subseteq \{ \deltaA_A (t_{Q,Q'},X) \mid X \subseteq \Nodes {t_{Q,Q'}}\}$  we have that
	$T = \deltaA_A(P,Q,(a,"*")) \subseteq \{ \deltaA_A (t_{T,T'},X) \mid X \subseteq \Nodes {t_{T,T'}}\}$. We have proven \Cref{lem:prop1}.

	We will prove \Cref{lem:prop2} by case distinction.
	Let $X \subseteq \Nodes {t_{P,P'}}$ such that $\forall \sigma \in \Aut (t_{T,T'}), \sigma(X) = X$, we introduce the
	sets $X_1 = X \cap \Nodes {t_{P,P'}}$ and $X_2 = X \cap \Nodes {t_{Q,Q'}}$.
	\begin{itemize}
		\item Lets suppose $t_{P,P'} \cong t_{Q,Q'}$.
		      By \Cref{lem:prop3} of the induction hypothesis
		      $\interpret \Ua {t_{P,P'}} = (P,P')$ and $\interpret \Ua {t_{Q,Q'}} = (Q,Q')$, since $\interpret \Ua {\cdot}$ is a function
		      and $\interpret \Ua {t_{P,P'}} = \interpret \Ua {t_{Q,Q'}}$, we have that $P = Q$ and $P' = Q'$.

		      Let $\sigma$ be the "automorphism" over $\Nodes{T,T'}$ that swaps  $t_{P,P'}$ and $t_{Q,Q'}$.
		      We have that $\sigma (X) = X$. Since $\deltaA(X) = X$, $\deltaA$ must map $X_1$ to $X_2$, and the same is true for
		      $X_2$. So we have that $X_1 = X_2$ which means that $\deltaA(X_1) = X_1$. By construction we have that $p := \deltaA_A(t_{P,P'}, X_1) =  \deltaA_A(t_{Q,Q'}, X_2)$.
		      Using \Cref{lem:prop2} of the induction hypothesis, we find that $p \in P'$. So
		      $\deltaA_A (t_{T,T'}, X) = \deltaA_A(p,p,(a, \bit X {\treeroot})) \in T'$.

		\item Lets suppose $t_{P,P'} \ncong t_{Q,Q'}$, in this case we have that $P' \neq Q'$ or $P \neq Q$ and thus $T' = \deltauu (P',Q',a) = \deltaA_a(P',Q',(a,"*"))$.

		      We have to prove that
		      $\{ \deltaA_A (t_{T,T'},X) : \forall \sigma \in \Aut(t_{T,T'}), \sigma(X) = X\} \subseteq T'$.
		      Let $\sigma \in \Aut(t_{T,T'})$. Since $t_{P,P'} \ncong t_{Q,Q'}$, $\sigma$ cannot swap $t_{P,P'}$ and
		      $t_{P,P'}$.
		      Since we have that $\sigma(X) = X$, then we deduce that $\sigma(X_1) = X_1$ and
		      $\sigma(X_2) = X_2$, because $\sigma$ must acte on the "subtrees" independently (because the "subtrees" are not isomorphic).
		      Let $p := \deltaA_A (t_{P,P'}, X_1)$ and $q := \deltaA_A (t_{Q,Q'}, X_2)$.
		      Using \Cref{lem:prop2} of the induction hypothesis we deduce that $p \in P'$ and $q \in Q'$.
		      So $\deltaA_A (t_{T,T'}, X) = \deltaA_A(p,q,(a, X(\treeroot))) \in T'$.
	\end{itemize}
	We have proven the three properties.

	Lets prove the lemma by exhibiting that no $X$ verifying $t_{R,R'} \models \phi(X)$ is invariant under the "automorphisms" of $t_{R,R'}$.
	Since $R \cap F \neq \emptyset$, there exists $X$ that models $\phi(X)$ and  belonging to $R \cap F$. We can use \Cref{lem:prop1} to deduce that
	$X \in \{ \deltaA_A (t_{R,R'},X) \mid X \subseteq \Nodes {t_{R,R'}}\} \cap F$.
	We also know that $R' \cap F = \emptyset$, we can the deduce that $\{ \deltaA_A (t_{R,R'},X) \mid \forall \sigma \in \Aut(t_{R,R'}), \sigma(X) = X\} \cap F = \emptyset$
	thanks to \Cref{lem:prop2}. So we know that $X \notin \{ \deltaA_A (t_{R,R'},X) \mid \forall \sigma \in \Aut(t_{R,R'}), \sigma(X) = X\} \cap F = \emptyset$ which means that no
	$X$ satisfying $t_{P,P'} \models \phi(X)$ is invariant under the "automorphisms" of $t_{R,R'}$.
\end{proof}

\Cref{lem:main-result} is then proved. We can conclue with a simple proof of our main theorem.

\begin{proof}[Proof of \Cref{thm:uniformisability-decision}]
	\Cref{lem:main-result} states the equivalence between the "uniformisability" of a formula $\phi(X)$ and the "universality" of its "uniformiser automaton" $\Ua$.
	We can use the "uniformisability checking algorithm" to construct $\Ua$ and check whether it is "universal". This algorithm decides whether $\phi(X)$ is "uniformisable".
\end{proof}

\section{Conclusion}

\todo{write}

\bibliographystyle{plainurl}
\bibliography{tre-uniformisation}

\end{document}
