\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath, amssymb, amsthm, mathtools}
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{thmtools}
\usepackage{stmaryrd}

\usepackage{tikz}
\usetikzlibrary{arrows.meta,automata,positioning,calc,trees}
\usepackage{tikz-cd}
\usepackage{graphicx}

\usepackage[shortlabels]{enumitem}
\usepackage{caption}

\usepackage{hyperref}
\usepackage{cleveref}

\usepackage[hyperref]{knowledge}
\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}

\bibliographystyle{plainurl}


\input{macros}
\input{tre-uniformisation.kl}

%\hypersetup{
%    pdftitle={\papertitle},
%    pdfauthor={\paperauthorone, \paperauthortwo},
%    colorlinks=true,
%    linkcolor=blue,
%    citecolor=blue,
%    urlcolor=blue
%}

%\fancyhf{}
%\fancyhead[LO]{\textit{\papertitle}}
%\fancyhead[RE]{\textit{\paperauthorone, \paperauthortwo}}
%\fancyhead[RO]{\thepage}
%\fancyhead[LE]{\thepage}

%\pagestyle{fancy}



\title{Decidability of MSO Uniformisation on Finite Trees}

\author{Thomas Colcombet}
	{CNRS, IRIF, Universit\'e Paris Diderot, France}
	{thomas.colcombet@irif.fr}
	{https://orcid.org/0000-0001-6529-6963}
	{}

\author{Yago Iglesias Vázquez}{Universit\'e Paris Diderot, France}{...}{}{}
\nolinenumbers %uncomment to disable line numbering


\authorrunning{T. Colcombet, Y. Iglesias Vázquez} 

\Copyright{Thomas Colcombet, Yago Iglesias Vázquez} 

\ccsdesc[500]{Theory of computation~Finite Model Theory}
\ccsdesc[500]{Theory of computation~Algebraic language theory}
\ccsdesc[500]{Theory of computation~Regular languages}

\keywords{MSO, uniformization, finite state automata, trees} 

\category{Rapport de stage} 

\relatedversion{} 

\begin{document}

\maketitle

\begin{abstract}			\todo{knowledge all of this}
			We study uniformisation for MSO formulas over finite binary trees. A formula $\psi(X)$ uniformises $\phi(X)$
			if it selects at most one witness $X$ and, whenever $\phi$ has a witness, $\psi$ picks one. We show that,
			using symmetry-preserving automata (order-insensitive automata), it is decidable whether a
			given $\phi$ admits such a uniformiser, and in the positive case, we effectively construct $\psi$. Our procedure translates $\phi$ into
			an order-insensitive deterministic bottom-up tree automaton, checks whether that automaton accepts every tree, and—when
			it does—extracts from its transition relation an MSO formula that uniformly selects a witness. This reduces MSO uniformisation
			on unordered trees to a simple automata universality test and a formula extraction step.
\end{abstract}

\tableofcontents
\newpage
\section{Introduction}

Monadic second‐order (MSO) logic is a well-studied fragment of second-order logic with wide-ranging applications in graph theory, automata theory, and formal verification.
In particular, its deep connection with automata theory has been extensively explored. It is well known that MSO over finite words is equivalent in expressive power to
finite-state automata~\cite{buchi60}.

This correspondence extends beyond words: automata can also be defined to run on "trees". Over finite "trees", MSO logic remains equivalent in expressive power to finite-state
tree automata~\cite{TW68, Don70}. This connection enables the use of automata-theoretic techniques to reason about "trees", one of the most fundamental and widely studied data
structures.

A classical challenge in this context is the \emph{uniformisation problem}: given an MSO formula $\phi(X)$ that asserts the existence of a set $X$ satisfying a certain property,
is it possible to define another MSO formula $\psi(Y)$ that selects \emph{at most one} such set for each tree, in a way that agrees with $\phi$ whenever it is satisfiable? We
formalize this notion in \Cref{sec:uniformisation}.

This problem has been studied in various settings. A comprehensive survey is provided in~\cite{Cara15}. Positive results are known for infinite words, where every MSO-definable
relation admits an MSO-definable uniformising function~\cite{Siefkes1975, Choffrut1999, Rabin07}. In contrast, uniformisation is not possible in general for infinite binary
trees~\cite{GS83}.
In this work, we study MSO uniformisation over a different class of structures: \emph{finite, labeled binary trees}.
All of the technical work is performed using only automata that preserve structural symmetry,
\ie they are unable to distinguish between left and right subtrees.

The central question addressed in this paper is:

\begin{problem}[The ""uniformisation"" problem]\label{prob:uniformisation-problem}
\AP Given an MSO formula $\phi(X)$, does there exist a "uniformiser" $\psi(X)$?
\end{problem}

Our main result is that this question is \emph{decidable}, and in the positive case, a "uniformiser" $\psi$ can be effectively constructed. Concretely, we translate $\phi$ into a
"deterministic bottom-up tree automaton" whose "transition map" is "order-insensitive" (\ie closed under sibling swaps). We then perform a "universality" check on this
automaton—does it accept every tree?—and, when it does, we extract from its transitions an MSO formula that uniformly selects a witness.

This paper makes three main contributions:
\begin{itemize}
	\item Extending the decidability of MSO "uniformisation" to finite binary "trees" using only symmetry preserving automata,
	\item Providing a constructive method to extract a "uniformiser" via "automata universality", and
	\item Demonstrating how to handle sibling‐permutation symmetry in "tree" transformations.
\end{itemize}

\paragraph*{Structure of the paper.} The remainder of the paper is structured as follows:
\Cref{sec:uniformisation} brings these elements together to decide MSO "uniformisation" and construct a "uniformiser" where possible.
We conclude with related work and future research directions.

\section{Definitions}
\label{sec:definitions}

In this section, we present classical notions of trees, automata and logic.
\Cref{sec:trees} introduces our notation for trees and MSO logic.
\Cref{sec:automata} reviews bottom‐up tree automata, presents the order‐insensitive variant, and defines the universality test.
\Cref{sec:MSO} shows how to translate between MSO formulas and automata while preserving order insensitivity.


\subsection{Trees}\label{sec:trees}

This first section contains the definition of the "trees" we are working with. Other equivalent definitions of "trees" and
automata are possible~\cite{Thomas1997, tata}, but we have chosen this one because it is more intuitive, without adding much complexity to the proofs.

\begin{definition}["Tree"]
	\AP A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$;
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are "trees".
	\end{itemize}
	We call the ""root"" of a "tree" the first node in its definition.
	The set of all "trees" over $\Sigma$ is denoted $\intro* \tree_{\Sigma}$.
\end{definition}

\begin{figure}[h]
	\centering

	\begin{tikzpicture}[
			level distance=1cm,
			sibling distance=1.5cm,
			every node/.style = {draw, circle}
		]

		\node {a}
		child { node {b} }
		child { node {c}
				child { node {d} }
				child { node {e} }
			};

	\end{tikzpicture}

	\caption{Concrete tree corresponding to $a(b, c(d, e))$.}
\end{figure}

This recursive structure induces a natural notion of position within a "tree". We now define the set of "nodes",
represented as words over $\{0,1\}$ indicating a path from the root.

\begin{definition}["Nodes"]
	\AP The ""nodes"" of a "tree" are defined as follows:
	\[
		\intro* \Nodes t =
		\begin{cases}
			\varepsilon                             & \text{if } t = a         \\
			\varepsilon \cup \setdef {0u} {u \in \Nodes {t'}}
			\cup \setdef {1u} {u \in \Nodes {t''} } & \text{if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}

\begin{example}
	Let $ t := a(b, c(d, e)) $. We compute:
	\[
		\Nodes b  = \{\varepsilon\}, \quad \Nodes {c(d, e)} = \{\varepsilon, 0, 1\}
	\]
	\[
		\Nodes t = \{\varepsilon\} \cup \{0\} \cup \{1, 10, 11\} = \{\varepsilon, 0, 1, 10, 11\}
	\]
\end{example}

Among the "nodes", some are distinguished as "leaves", "nodes" without children.

\begin{definition}["Leaves"]
	\AP The ""leaves"" of a "tree" are defined as follows:
	\[
		\intro* \Leaves t = \begin{cases}
			\varepsilon                              & \text{if } t = a         \\
			\setdef {0u} {u \in \Leaves {t'}}
			\cup \setdef {1u} {u \in \Leaves {t''} } & \text{if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}

\begin{remark}
	$\Leaves t \subseteq \Nodes t$.
\end{remark}

\begin{definition}
	We call ""internal nodes"" the set $\Nodes t \cap \Leaves t$
\end{definition}


Each "node" in a "tree" carries a symbol from the alphabet. The following definition formalizes how to
access the "label" at a given "node".

\begin{definition}
	\AP We note $\intro* \tlabel t n$ the ""label"" of the "node" $n$ in the "tree" $t$:
	\[
		\tlabel t n =   \begin{cases}
			a               & \text{if } t = a \text{ and } n = \varepsilon         \\
			a               & \text{if } t = a(t',t'') \text{ and } n = \varepsilon \\
			\tlabel {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m          \\
			\tlabel {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}

We often need to refer to the "subtree" rooted at a particular "node". The next definition allows us to
extract such a "subtree" from a given "tree".

\begin{definition}
	\AP We note $\intro* \subtree t n$ the ""subtree"" corresponding to the "node" $n$ in the "tree" $t$:
	\[
		\subtree t n =   \begin{cases}
			t                & \text{if }  n = \varepsilon                  \\
			\subtree {t'} m  & \text{if } t = a(t',t'') \text{ and } n = 0m \\
			\subtree {t''} m & \text{if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}

The "ancestor" relation captures the natural hierarchical structure of a "tree": a "node" $x$ is an "ancestor"
of a "node" $y$ if $y$ is located in the "subtree" rooted at $x$.

\begin{definition}
	\AP Let $t$ be a "tree" and $x, y \in \Nodes t$. We define the ""ancestor"" relation as:
	\[
		x \intro* \ancestor y \tiff \exists z \in \Nodes t,\, y = xz
	\]
\end{definition}

\begin{remark}
	Note that this order does not depend on the left or right position of the children, \ie it preserves
	"order-insensitivity", this will be explored in the following sections.
\end{remark}


\subsection{Automata over trees}\label{sec:automata}

In this section we aim to define the basics of tree automata in a comprehensive way adding as much detail as possible to the proofs. For reference,
one can look at more advanced book on this topic \cite{tata,Thomas1997,bookautomata}.

In classical automata theory, we analyze deterministic finite automaton (DFA), wich assign a unique state to each prefix of
a word, updating this state at each step using a transition function, ussualy reading the input from left to right.

A "deterministic bottom-up tree automaton" ("DBUA") generalizes this idea to "trees": instead of reading a linear word, it reads a
a "tree" where each "node" carries a symbol from a fixed alphabet. Rather than scanning from left to right, it proceeds
bottom-up, computing "states" at each "node" by combining the states of its children :
the automaton aggregates the information from those "subtrees" to assign a "state" to the parent.

The idea is to recursively assign a "state" to each "node" of the "tree":
\begin{itemize}
	\item At the "leaves", the "state" is determined directly from the symbol via a function init, just as a DFA starts in a particular initial state.
	\item A DFA transitions based on the current letter and the state reached by the previous letters.
	      When a "NBUA" reaches an "internal node", it transitions based on the "states" reached by its children and the "label" associated to the "node".
	\item Finally, the "state" assigned to the "root" tells us whether the whole "tree" is "accepted",
	      depending on whether it belongs to a set of "final states".
\end{itemize}

We now state the formal definitions.

\begin{definition}
	\AP A ""deterministic bottom-up tree automaton"" (\reintro*"DBUA") is a tuple $(\Sigma, Q, \text{init}, \delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		      \itemAP $Q$ is a finite set of ""states"".
		\item $\intro *\init : \Sigma \to Q$ is a function that initializes the states of the "leaves".
		      \itemAP $\delta : Q \times Q \times \Sigma \to Q$ is the ""transition map"".
		      \itemAP $F \subseteq Q$ is the set of ""final states"".
	\end{itemize}
\end{definition}

\begin{definition}[Interpretation of an automaton]
	\AP The ""interpretation"" of a "DBUA" $A = (\Sigma, Q, \init, \delta, F)$  over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\intro* \interpret A ~: \tree_{\Sigma} &\to& Q \\
		a &\mapsto& \init_a \\
		a(t,t') &\mapsto& \delta_a (\interpret A t, \interpret A {t'})
	\end{eqnarray*}

	We say that $A$ ""accepts"" a "tree" $t$ if $\interpret A t \in F$.

	We will sometimes use the notation $\delta(t)$ for the "interpretation" of $A$ over the "tree" $t$.
\end{definition}

\begin{example}[Trees with at most one leaf]\label{ex:count-leaves}
	We define a "DBUA" $A = (\Sigma, Q, \init, \delta, F)$ that "accepts" exactly the "trees" with at most one "leaf". Let:
	\begin{itemize}
		\item $Q = \{0,1,2\}$, where $q=0$ means \textit{no leaves}, $q=1$ means \textit{exactly one leaf},
		      and $q=2$ means \textit{more than one leaf}.
		\item $F = \{0,1\}$.
		\item For all $a \in \Sigma$, we define $\init_a = 1$.
		\item The transition function is defined by:
		      \[
			      \delta_a(q_1, q_2) = \min(q_1 + q_2, 2)
		      \]
	\end{itemize}

	Intuitively, this automaton counts the number of "leaves" in the "tree", but caps the count at $2$ to detect when the number exceeds $1$.
	\Cref{fig:count-leaves} illustrates the execution of this automaton over a particular input.
\end{example}


\begin{figure}[h]\label{fig:count-leaves}
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			sibling distance=1.3cm,
			every node/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			treenode/.style={circle,draw,minimum size=6mm,inner sep=1pt},
			scale=1, transform shape,
			state/.style={blue}
		]

		% TREE 1
		\node (t1) at (0,0) {a}
		child {node (t1b1) {b}}
		child {node (t1a2) {a}
				child {node (t1b3) {b}}
				child {node (t1b4) {b}}};

		\node at (2.2, -1) {$\Rightarrow$};

		% TREE 2
		\node (t2) at (4.5,0) {a}
		child {node[state ](t2b1) {1}}
		child {node (t2a2) {a}
				child {node[state] (t2s2) {1}}
				child {node[state] (t2s3) {1}}};

		\node at (6.7, -1) {$\Rightarrow$};

		% TREE 3 
		\node (t3) at (9,0) {a}
		child {node[state] (t3s4) {1}}
		child {node[state] (t3a2) {2}};

		\node at (11.2, -1) {$\Rightarrow$};

		% TREE 4 
		\node[state] (t4) at (13.5,0) {2};

	\end{tikzpicture}
	\caption{Execution of the automaton of \Cref{ex:count-leaves} over the input $a(b,a(b,b))$}
\end{figure}


In future sections, we will extensively use these notations.

\begin{notation}
	We note $\delta(X,Y, (a, *))$ for $\{ \delta(X,Y,(a,b)) \}  \mid  x \in X, y \in Y, b \in \set{0,1}\}$ and
	$\init(a,*)$ for $\setdef{\init(a,b)} {b \in \set{0,1}}$
	\todo{improve this notation}
\end{notation}


In the same way that we can define a non-deterministic automaton over strings, the same can be done for
tree automata using the same techniques. We will define them and give basic definitions on how to use them.

\begin{definition}
	\AP A ""Non-Deterministic Bottom-Up Tree automaton"" (NBUA) is defined as a tuple
	$(\Sigma, Q, I, \Delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of "states".
		\item $I \subseteq \Sigma \times Q$ correspond to the possible states of the "leaves".
		      \itemAP $\Delta \subseteq Q \times Q \times \Sigma \times Q$ is the ""transition relation"".
		\item $F \subseteq Q$ is the set of "final states".
	\end{itemize}
\end{definition}

\begin{definition}[Run of an automaton]
	\AP A ""run"" $\intro* \exec$ of a "NBUA" $A$ over a "tree" $t$ is :

	\begin{eqnarray*}
		\exec : \Nodes t &\to& Q \\
		(\tlabel t b,  \exec (n) ) \in I &\text{ if }& n \in \Leaves t \\
		(\exec (n0), \exec (n1), \tlabel t n, \exec (n)) \in \Delta &\text{ if }& n \in \Nodes t \setminus \Leaves t
	\end{eqnarray*}

	We say that $\exec$ is "acceptant" if $\exec (\varepsilon) \in F$ and $A$ "accepts" $t$ if
	$F \cap \setdef {\rho(\varepsilon)} {\text{$\rho$ "run" of~$A$ over~$t$}} \neq \emptyset$
\end{definition}


\begin{definition}[Language of an automaton]
	\AP Let $A$ be a "NBUA". Its ""associated language"" is defined as:
	\[\intro* \lang A = \setdef {t \in \tree_{\Sigma}} {\text{exists $\rho$ a "accepting" "run" of $A$ over $t$}} \]
\end{definition}

We can easily see that "DBUA" are a particular case of "NBUA", just like in the classic theory.

\begin{remark}
	Every "DBUA" $A = (\Sigma, Q, \init, \delta, F)$ can be seen as a special case of a "NBUA"
	$A' = (\Sigma, Q, I, \Delta, F)$ where:
	\begin{itemize}
		\item $I = \setdef{(a, \init_a)}{a \in \Sigma}$,
		\item $\Delta = \setdef{(q_1, q_2, a, \delta_a(q_1, q_2))}{q_1, q_2 \in Q, a \in \Sigma}$.
	\end{itemize}

	In this case, $A'$ has exactly one possible "run" on each "tree" :

	\begin{eqnarray*}
		\exec : \Nodes t &\to & Q \\
		n  &\mapsto& \init_{\tlabel t n} \text{ if } n \in \Leaves t \\
		n  &\mapsto& \delta_{\tlabel t n}(\exec (n0), \exec (n1)) \text{ if } n \in \Nodes t \setminus \Leaves t
	\end{eqnarray*}
\end{remark}

The following lemma shows the equivalence of both definitions.

\begin{lemma}
	Let $A$ be a "DBUA",
	\[ \lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A t \in F} \]
\end{lemma}

\begin{proof}
	We will prove by induction on a "tree"~$t$ that (a) there exists a "run" of~$A$ over~$t$, and (b) for all "runs"~$\exec$ of $A$ over $t$, $\interpret A t = \exec (\varepsilon)$.
	We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$. Let $\rho$ be defined by $\rho(\varepsilon)=\init_a$, then $\rho$ is a "run" of~$A$ over~$t$. We have proved (a).
		      Consider now some "run" $\rho$ of $A$ over~$t$. We have $\rho(\varepsilon)=\init_a=\interpret A a=\interpret A t$. We have proved  (b).

		\item If $t = a(t',t'')$. By induction hypothesis (a), there exists "runs"~$\rho'$ and $\rho''$ on~$t'$ and $t''$ respectively.
		      Let~$\rho$ be defined by $\rho(\varepsilon)=\delta_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon))$,
		      $\rho(0u)=\rho'(u)$ for all $u\in\Nodes{t'}$ and $\rho(1u)=\rho''(u)$ for all~$u\in \Nodes{t''}$. Then $\rho$ is a "run" of~$A$ over $t$. We have proved (a).

		      Consider now some "run" $\rho$ of $A$ over $t$. Let~$\rho'(u)=\rho(0u)$ for all $u \in \Nodes {t'}$ and $\rho''(u)=\rho(0u)$ for all $u \in \Nodes {t''}$.
		      Then $\rho'$ is a "run" of~$A$ over $t'$ and $\rho''$ over $t''$. By induction hypothesis (b) twice, we know that $\rho'(\varepsilon)=\interpret A {t'}$ and $\rho''(\varepsilon)=\interpret A {t''}$.
		      We have now $\rho(\varepsilon) = \delta_{t(\varepsilon)}(\rho'(\varepsilon),\rho''(\varepsilon)) = \delta_{t(\varepsilon)}(\interpret A {t'},\interpret A {t''}) = \interpret A t$. We have proved (b).
	\end{itemize}
\end{proof}


We aim now to show that, like in the classical theory, both non-deterministic automata and deterministic ones have the same expressiveness power.
Since "DBUA" is a particular case of "NBUA" it suffices to show that each "language" accepted by an "NBUA" can also be accepted by a "DBUA".

\begin{definition}
	Let $A = \NBUA$ be a "NBUA", we define the ""power set automaton"" of $A$, noted $\intro* \Det A$, as
	$\Det A = (\Sigma, \parts Q, \text{init}, \delta, F')$ where:

	\begin{itemize}
		\item $\begin{aligned}[t]
				      \init      : \Sigma & \to \parts Q                          \\
				      a                   & \mapsto \setdef{q \in Q}{(a,q) \in I}
			      \end{aligned} $

		\item $\begin{aligned}[t]
				      \delta               : \parts Q \times \parts Q \times \Sigma & \to \parts Q                                                     \\
				      (X, Y, a)                                                     & \mapsto \setdef{q \in Q}{(x,y,a,q) \in \Delta, x \in X, y \in Y}
			      \end{aligned}$

		\item $F' = \setdef{X \in \parts Q}{X \cap F \neq \emptyset} \subseteq \parts Q$
	\end{itemize}
\end{definition}

\begin{theorem}
	For all $N = \NBUA$ an "NBUA", the "power set automaton" verifies that
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} \text{ and } \lang N = \lang {\Det N}
	\]
\end{theorem}

\begin{proof}
	We will first show that for all "tree" $t$,
	\[
		\interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}\ .
	\]
	We will prove this property by induction over $t$. We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$, then
		      \begin{eqnarray*}
			      \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}} &=&  \setdef {q \in Q} {(a,q) \in I} \\
			      &=& \interpret {\Det N} t\ .
		      \end{eqnarray*}
		\item If $t = a(t_1,t_2)$, then
		      by the induction hypothesis we know that
		      $\interpret {\Det N} {t_i} = q_i$ \tiff there exists a "run" over $t_i$ ending at $q_i$, for $i \in \set {1,2}$.

		      \begin{eqnarray*}
			      &&q \in \interpret {\Det N} t \\
			      &\text{if and only if}& q \in \delta_a (\interpret {\Det N} {t_1}, \interpret {\Det N} {t_2}) \\
			      &\text{if and only if}& q \in \setdef {q \in  Q} {(x_1,x_2,a,q) \in \Delta, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2}} \\
			      &\text{if and only if}& \exists x_1,x_2, (x_1,x_2,a,q) \in \Delta, x_1 \in \interpret {\Det N} {t_1}, x_2 \in \interpret {\Det N} {t_2} \\
			      &\text{if and only if}& \text{there exists a "run" over }  t_i  \text { ending at } x_i \text { for  } i \in \set {1,2} \text{ and } (x_1,x_2,a,q) \in \Delta\\
			      &\text{if and only if}& q \in \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}
		      \end{eqnarray*}
	\end{itemize}
	Then $ \interpret {\Det N} t = \setdef {\rho(\varepsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}$.\\

	We must now show that $\Det N$ "accepts" $t$ \tiff $N$ "accepts" $t$.
	\begin{eqnarray*}
		N \text{ "accepts" } t &\tiff& F \cap \setdef {q \in Q} {(a,q) \in I} \neq \emptyset \\
		&\tiff&   F \cap  \interpret {\Det N} t \neq \emptyset \\
		&\tiff& \interpret {\Det N} t  \in F' \\
		&\tiff& {\Det N} \text{ "accepts" } t
	\end{eqnarray*}
	and so $\lang N = \lang {\Det N}$.
\end{proof}


\subsection{Order-insensitivity}\label{sec:OrderAutomata}

We will interest ourselves in a particular kind of tree automata: the ones that do not distinguish between left and right children.
That means that the state reached from the two children is the same if we swap them. These automata are
interesting because they respect the symmetries of "trees".

\begin{definition}
	An "NBUA" of "transition relation"~$\Delta$ is ""order-insensitive"" if for all "transitions@@relation" $(p,q,a,r) \in \Delta$,
	$(q,p,a,r) \in \Delta$.
\end{definition}

\begin{remark}\label{def:order-insensitive}
	For a "DBUA" of "transition map"~$\delta$, it is "order-insensitive" if and only if
	$\delta_a (p,q) = \delta_a (q,p)$ for all "states"~$p,q$ and letter~$a$.
\end{remark}


\begin{figure}[h]
	\centering
	\begin{tikzpicture}[
			level distance=1.2cm,
			level 1/.style={sibling distance=1.5cm},
			every node/.style={draw, circle},
			baseline={(current bounding box.center)}
		]

		% Left Tree
		\node (root1) {$a$}
		child {node {$t_1$}}
		child {node {$t_2$}};

		% Right Tree
		\node (root2) at (6,0) {$a$}
		child {node {$t_2$}}
		child {node {$t_1$}};

		% State s
		\node[draw=blue] (s) at (3, -0.5) {$s$};

		% Arrows
		\draw[->, thick, draw=blue] (root1) to[out=0, in=180] node[draw=none, midway, below] {\(\delta_a\)} (s);
		\draw[->, thick, draw=blue] (root2) to[out=180, in=0] node[draw=none, midway, below] {\(\delta_a\)} (s);

	\end{tikzpicture}
	\caption{Illustration of "order-insensitivity" in a "DBUA" (see \Cref{def:order-insensitive}).
		Both trees yield the same state $s$ under the transition map $\delta_a$.}
	\label{fig:order-insensitivity}
\end{figure}



\begin{lemma}
	If $N = \NBUA$ a "NBUA" is "order-insensitive", then $\Det N$ is also "order-insensitive".
\end{lemma}

\begin{proof}
	\begin{eqnarray*}
		\delta_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \Delta, x \in X, y \in Y}  \reason {$N$ is "order-insensitive"} \\
		&=& \delta_a (Y,X)
	\end{eqnarray*}
\end{proof}


\subsection{Universality}\label{sec:UniversalityAutomata}

\begin{definition}
	Let $A = \DBUA$ a "DBUA", let $\intro* \Reach A \subseteq Q$ be the smallest set such that
	\begin{enumerate}
		\item $\init (a) \in \Reach A$ for all $a \in \Sigma$,
		\item $\delta (p,q,a) \in \Reach A$ for all $p,q \in \Reach A$ and $a \in \Sigma$.
	\end{enumerate}
\end{definition}


\begin{lemma}
	Let $A$ a "DBUA", then
	\[\Reach A = \setdef {\interpret A t} {t \in \tree_\Sigma} \]
\end{lemma}


\begin{proofI}
	\begin{itemize}
		\item $\bsubLR$\vspace{0.15cm}\\
		      We will prove by induction that $r \in \Reach A \implies$ there exists $t \in \tree_\Sigma$ such that
		      $\interpret A t = r$.

		      \begin{itemize}
			      \item If $r = \init(a) \in \Reach A$, then the "tree" $a$ works : $\interpret A a = \init (a) = r$.
			      \item If $r = \delta (p,q,a) \in \Reach A$ where $p,q \in \Reach A$ and $a \in \Sigma$. Then by the induction hypothesis
			            there exists $t'$ such that $\interpret A {t'} = p$ and $t''$ such that $\interpret A {t''} = q$.
			            Then we have that $t = a(t',t'')$ verifies $\interpret A t = r$.
		      \end{itemize}
		\item $\bsubRL$\vspace{0.15cm}\\
		      We will prove it by induction on the structure of a "tree" $t$. We proceed by case distinction.
		      \begin{itemize}
			      \item If $t = a$, then we have $ \interpret A a = \init (a) \in \Reach A$
			      \item If $t = a(t',t'')$, we have $ \interpret A t = \delta(\interpret A {t'}, \interpret A {t''}, a) \in \Reach A$
			            because by the induction hypothesis $\interpret A {t'} \in \Reach A$  and $\interpret A {t''} \in \Reach A$.
		      \end{itemize}
	\end{itemize}
\end{proofI}

\begin{definition}
	Let $A $ a "NBUA" we say that it is ""universal"" if it "accepts" every "tree".
\end{definition}


\begin{theorem}
	$A = \DBUA$ is "universal" if and only if $\Reach A \subseteq F$.
\end{theorem}

\begin{proofI}
	\begin{itemize}
		\item $\bimpLR$\\
		      We suppose $A$ "universal", then for all $t \in \tree_\Sigma$ we have that $\interpret A t \in F$, because $A$ "accepts" $t$.
		      Since $\Reach A = \setdef {\interpret A t} {t\in \tree_\Sigma}$ we have that $\Reach A \subseteq F$.

		\item $\bimpRL$\\
		      We suppose $\Reach A \subseteq F$. Let $t$ be a "tree", then $\interpret A t \in \Reach A \subseteq F$, so $\interpret A t \in F$ and $A$
		      "accepts" $t$. We have proven that $A$ is "universal".
	\end{itemize}
\end{proofI}


\begin{coro}\label{coro:univeral-Reach}
	A saturation algorithm based on $\Reach A$ decides "universality".
\end{coro}


\subsection{Monadic second-order logic}\label{sec:MSO}

In this section, we introduce "Monadic Second-Order Logic" (MSO) over finite binary "trees",
and examine its relationship with "non-deterministic bottom-up automata", in partivulat with "order-insensitive" automata.

We will use this equivalence later to reason about "MSO" formulas using automata-theoretic techniques. In particular, this will allow us to:

Our objective is to show that "MSO" and "order-insensitive" "automata@NBUA" have the same expressive power. This will allow to reason about
properties of MSO using automata theory techniques, wich will be extensively use in \Cref{sec:uniformisation}.

The proof follows the classical schema.

We start by showing that every "automaton@NBUA" can be expressed as a formula. The proof itself is standard \cite{Buchi60, Thomas1997, bookautomata}.

\begin{definition}
	Let $t \in \tree_{\Sigma}$. We define a ""model"" of $t$ as:

	\[
		\Model t := (\Nodes t, \ancestor , (a (x))_{a \in \Sigma})
	\]

	where each unary predicate $a(x)$ holds if and only if $\tlabel t x = a$.

	We write $t \models \phi$ to mean that the formula $\phi$ holds in the "model" $\Model t$.
\end{definition}

We will discuss some examples of "MSO" formulas.

\begin{example}
	The formula
	\[
		\leaf(x) = \forall y,\, y \ancestor x
	\]
	expresses the fact that $x$ is a "leaf", a node without descendants.
\end{example}

\begin{example}
	The formula
	\[
		\treeroot(x) = \forall y,\, x \ancestor y
	\]
	defines the "root" of the "tree", meaning a node that is an "ancestor" of every other node.
\end{example}

\begin{example}
	The following formula expresses that $x$ and $y$ are the immediate children of a node $z$:
	\[
		\children(x,y,z) =
		x \neq y \land
		z \ancestor x \land  z \ancestor y \land
		\forall w
		\left( \left(
			z \ancestor w \land
				(w \ancestor x \lor w \ancestor  y) \right) \rightarrow (
			w = x \lor w = y
			)
		\right)
	\]
\end{example}

We now show how to simulate an "automaton@NBUA" by a formula. The idea is to encode the existence of a valid "run" of 
the "automaton@NBUA" using second-order variables that assign "states" to "nodes".

\begin{lemma}
	If $A$ is an "order-insensitive" "NBUA", then there exists a "MSO" formula $\phi$ such that for all $t \in \tree_{\Sigma}$,
	\[
		t \models \phi \tiff t \in \lang A.
	\]
\end{lemma}

\begin{proof}\label{lem:Aut-to-MSO}
	Let $A = \NBUA$ be an "order-insensitive" "NBUA", and let $k = \abs Q$ be the number of "states".

	\begin{align}
		\phi =\  & \exists X_0 \ldots \exists X_{k-1} \ \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \label{lem:AMSO1}                                                                                    \\
		         & \land\ \forall x \left( \bigwedge_{0 \leq i < j \leq k-1} \lnot (X_i(x) \land X_j(x)) \right) \label{lem:AMSO2}                                                                               \\
		         & \land\ \forall x \left( \leaf(x) \rightarrow \bigvee_{(a,i) \in I} X_i(x) \right) \label{lem:AMSO3}                                                                                           \\
		         & \land\ \forall x\, \forall y\, \forall z \left(\children(x,y,z) \rightarrow \bigvee_{(p,q,a,r) \in \Delta} \left(X_p(x) \land X_q(y) \land a(z) \land X_r(z)\right) \right) \label{lem:AMSO4} \\
		         & \land\ \forall x \left( \treeroot(x) \rightarrow \bigvee_{q \in F} X_q(x) \right) \label{lem:AMSO5}
	\end{align}

	The sets $X_i$ encode the "run" of the automaton: $x \in X_i$ means that the "state" $i$ is assigned to the "node" $x$ in some valid accepting "run".

	The formula ensures:

	\begin{itemize}
		\item[\ref{lem:AMSO1}] Every "node" is assigned some "state".
		\item[\ref{lem:AMSO2}] No "node" is in more than one "state".
		\item[\ref{lem:AMSO3}] "Leaf" nodes are assigned an initial "state".
		\item[\ref{lem:AMSO4}] For each triple $(x,y,z)$ forming a parent and its two children,
            there exists a transition in $\Delta$ from the children to the parent.
		\item[\ref{lem:AMSO5}] The "root" is labeled with a final "state".
	\end{itemize}

	Therefore, the formula defines the same "language" as the automaton:
	\[
		t \models \phi \iff t \in \lang A.
	\]
\end{proof}

We now turn to the other direction. Our goal is to show that for every "MSO" formula over finite binary "trees", 
there exists an equivalent "order-insensitive" "non-deterministic bottom-up automaton".

The construction proceeds by induction on the structure of formulas, using standard constructions for closure and the atomic formulas.
Throughout, we ensure that the resulting automata remain "order-insensitive".

We begin with basic closure properties of such automata.

\begin{lemma}[Intersection]\label{lem:intersection}
	Let $A_1 = (\Sigma, Q_1, I_1, \Delta_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \Delta_2, F_2)$ be two "order-insensitive" "NBUAs". Then the product automaton
	\[
		A_3 = (\Sigma, Q_1 \times Q_2, I_1 \times I_2, \Delta, F_1 \times F_2),
	\]
	where
	\[
		\Delta = \left\{ ((q_1,q_2), (p_1,p_2), (a_1,a_2), (r_1,r_2)) \,\middle|\, (q_1,p_1,a_1,r_1) \in \Delta_1,\ (q_2,p_2,a_2,r_2) \in \Delta_2 \right\},
	\]
	is "order-insensitive", and satisfies $\lang{A_3} = \lang{A_1} \cap \lang{A_2}$.
\end{lemma}

\begin{lemma}[Union]\label{lem:union}
	Let $A_1 = (\Sigma, Q_1, I_1, \Delta_1, F_1)$ and $A_2 = (\Sigma, Q_2, I_2, \Delta_2, F_2)$ be two "order-insensitive" "NBUAs". Then the disjoint union
	\[
		A_3 = (\Sigma, Q_1 \uplus Q_2, I_1 \uplus I_2, \Delta_1 \uplus \Delta_2, F_1 \uplus F_2)
	\]
	is also "order-insensitive", and it accepts precisely the union of the two languages: $\lang{A_3} = \lang{A_1} \cup \lang{A_2}$.
\end{lemma}

\begin{lemma}[Complement]\label{lem:complement}
	Given an "order-insensitive" "NBUA" $A = (\Sigma, Q, I, \Delta, F)$, the automaton
	\[
		A' = (\Sigma, Q, I, \Delta, Q \setminus F)
	\]
	is also "order-insensitive", and recognizes the complement of $A$: $\lang{A'} = \lang{A}^\complement$.
\end{lemma}

We now turn to atomic formulas. These are handled by explicitly designed automata over expanded alphabets that encode variable assignments.

\begin{lemma}\label{lem:atomic-a}
	Let $a \in \Sigma$. Over the alphabet $\Sigma \times \{0,1\}$, there exists an "order-insensitive" automaton deciding the atomic predicate $a(x)$, where $x$ is a free first-order variable. Define:
	\[
		A = (\Sigma \times \{0,1\}, \{\text{Yes}, \text{No}\}, \init, \delta, \text{Yes}),
	\]
	where:
	\begin{itemize}
		\item
		      \[
			      \init(a,1) = \text{Yes}, \quad \init(\_,\_) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \delta(\_, \_, (a,1))            & = \text{Yes} \\
				      \delta(\text{No}, \text{No}, \_) & = \text{No}  \\
				      \delta(\_, \_, \_)               & = \text{Yes}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}\label{lem:atomic-ancestor}
	There exists an "order-insensitive" automaton over $\Sigma \times \{0,1\}^2$ that decides the formula $x \ancestor y$. We define:
	\[
		A = (\Sigma \times \{0,1\}^2, \{\text{Yes}, \text{No}, \text{FoundY}\}, \init, \delta, \text{Yes}),
	\]
	with the following behavior:
	\begin{itemize}
		\item
		      \[
			      \init(\_,\_,1) = \text{FoundY}, \quad \init(\_,\_,0) = \text{No}
		      \]
		\item
		      \[
			      \begin{aligned}
				      \delta(\text{FoundY}, \_, (\_,1,0)) & = \text{Yes}    \\
				      \delta(\_, \text{FoundY}, (\_,1,0)) & = \text{Yes}    \\
				      \delta(\text{FoundY}, \_, (\_,0,0)) & = \text{FoundY} \\
				      \delta(\_, \text{FoundY}, (\_,0,0)) & = \text{FoundY} \\
				      \delta(\text{Yes}, \_, \_)          & = \text{Yes}    \\
				      \delta(\_, \text{Yes}, \_)          & = \text{Yes}    \\
				      \delta(\_, \_, (\_,0,1))            & = \text{FoundY} \\
				      \delta(\_, \_, \_)                  & = \text{No}
			      \end{aligned}
		      \]
	\end{itemize}
\end{lemma}

\begin{lemma}[from MSO to automata]\label{lem:MSO-to-aut}
	Let $\phi$ be an MSO formula. Then there exists an "order-insensitive" "NBUA" $A$ such that for every $t \in \tree_\Sigma$, we have:
	\[
		t \models \phi \quad \text{if and only if} \quad t \in \lang{A}.
	\]
\end{lemma}

\begin{proof}
	The construction proceeds by structural induction on $\phi$.

	To begin with, atomic formulas $a(x)$ and $x \ancestor y$ are handled by the automata in \Cref{lem:atomic-a,lem:atomic-ancestor}.

	In the case of conjunction and disjunction, using the induction hypothesis we get automata for its components, and we
	can build the automata for the whole expresión using \Cref{lem:intersection, lem:union}.


	If $\phi = \lnot \psi$, the induction hypothesis gives us an automaton for $\psi$ and we can apply \Cref{lem:complement}
	to get the desired one.

	The last step is the existential quantification. We strat by considering the first-order case: let $\phi = \exists x.\psi(x)$,
	and assume $\psi$ has $n$ free variables. By the inductive hypothesis, we have an "order-insensitive" NBUA
	\[
		A = (\Sigma \times \{0,1\}^n, Q, I, \Delta, F)
	\]
	that decides $\psi$, treating $x$ as free. We now construct a new automaton
	\[
		A' = (\Sigma \times \{0,1\}^{n-1}, Q \times \{0,1\}, I \times \{0\}, \Delta', F \times \{1\})
	\]
	that existentially guesses the position of $x$. The transition relation $\Delta'$ is defined as follows:
	\[
		\begin{aligned}
			\Delta' =\  & \left\{ ((q,b), (q',b'), (a, X), (q'', b \land b')) \ \middle|\
			(q, q', (a, X'), q'') \in \Delta,\ \text{$X'$ is $X$ with $0$ inserted at $x$} \right\} \\
			            & \cup \left\{ ((q,0), (q',0), (a, X), (q'',1)) \ \middle|\
			(q, q', (a, X'), q'') \in \Delta,\ \text{$X'$ is $X$ with $1$ inserted at $x$} \right\}.
		\end{aligned}
	\]

	In other words, $A'$ non-deterministically chooses a node to mark as $x$, simulates $A$ accordingly, and accepts if that guess leads to acceptance.

	If $\phi$ quantifies over a second-order variable, the automaton remains structurally unchanged. The interpretation shifts: instead of reading
	a single bit at a position, the automaton considers whether the current node belongs to the set assigned to that variable.

	Since each step in this construction preserves "order-insensitivity", the final automaton $A$ satisfies the desired equivalence.
\end{proof}


\section{Uniformisation}\label{sec:uniformisation}

\subsection{Definition of uniformisation}

\begin{definition}[Uniformiser]\label{def:uniformiser}
	We say that a formula $\psi(X)$ is a ""uniformiser"" of $\phi(X)$ if for all "trees" $t$, the following conditions hold:
	\begin{enumerate}
		\item There exists at most one set $X$ such that $t \models \psi(X)$.
		\item If there exists a set $X$ such that $t \models \phi(X)$, then there exists a set $Y$ such that $t \models \psi(Y) \land \phi(Y)$.
	\end{enumerate}

	We say that a formula is ""uniformisable"" if there exists a "uniformiser" for said formula.
\end{definition}


\iffalse
	\begin{lemma}
		$\psi(X)$ is a "uniformiser" of $\phi(X)$ if and only if for all "trees" $t$, the following holds:
		\begin{eqnarray*}
			t \models &\quad &  \forall X \forall Y \, \Big((\psi(X) \land \psi(Y)) \rightarrow X = Y\Big) \\
			& \land & (\exists X \, \phi(X)) \rightarrow (\exists X \, \psi(X)) \\
			& \land& (\forall X \, \psi(X) \rightarrow \phi(X)).
		\end{eqnarray*}
	\end{lemma}

	\begin{proof}
		We analyze the conditions in the first formulation and show their correspondence to the logical constraints in the second formulation:

		\begin{enumerate}
			\item The formula $\forall X \forall Y \, (\psi(X) \land \psi(Y) \rightarrow X = Y)$ ensures that $\psi$ has at most one solution
			      in $t$. This directly corresponds to the first condition in the original problem statement.

			\item The formula $\exists X \, \phi(X) \rightarrow \exists X \, \psi(X)$ expresses that whenever $\phi$ has a solution, $\psi$ must also have a solution.
			      However, this does not require $\psi$ to hold for the same one as $\phi$.

			      The formula $\forall X \, (\psi(X) \rightarrow \phi(X))$ ensures that whenever $\psi$ holds for a set, $\phi$ must also hold for that same set.

			      Combining the last two constraints, we obtain the second condition: whenever there exists a set satisfying $\phi$, there must exist a set
			      satisfying both $\psi$ and $\phi$.
		\end{enumerate}
	\end{proof}
\fi

\begin{definition}\label{def:definable}
	Let $t$ a "tree". We say that $X \subseteq \Nodes t$ is ""definable"" if there exists an MSO formula $\phi(x)$ such that $ X = \setdef{x} {t \models \phi(x)}$.
\end{definition}

\begin{lemma}
	An MSO formula $\phi(X)$ is "uniformisable" if for all "trees" $t$ there exists a "definable" $X_d$ such that $t \models \phi(X_d)$.
\end{lemma}

\begin{proof}
	\todo{~}
\end{proof}

\begin{lemma}\label{lem:def-aut}
	If $X$ is "definable" over a "tree" $t$, then for all $\sigma \in \Aut(t)$, $\sigma(X) = X$.
\end{lemma}

\begin{proof}
	\todo{~}
\end{proof}


In an intuitive way, \Cref{prob:uniformisation-problem} is equivalent to asking whether,
given a formula $\phi(X)$, the following ''formula'' holds for every "tree":

\[
	(\exists X.\, \phi(X)) \rightarrow (\exists X.\, \phi(X) \text{ and $X$ is "definable"})
\]

This can be interpreted as: if there exists a set of solutions for $\phi$, then there exists one that is "definable".

Our objective is to construct an automaton that captures the semantics of this formula. If such an automaton is "universal",
then it would mean that $\phi(X)$ is "uniformisable". To approach this, we begin by studying a simpler but related example.

Let us consider two formulas, $\phi(X)$ and $\psi(Y)$. Define

\[
	\Psi := (\exists X.\, \phi(X)) \rightarrow (\exists Y.\, \psi(Y))
\]

This formula resembles the previous one, it is, in fact, a generalisation. Studying whether it is valid over all "trees" will
help shed some light to the problem.

Since $\Psi$ is an MSO formula, we know that there exists a "DBUA" that decides it. In particular, thanks to the
construction from \Cref{lem:MSO-to-aut}, we can build a "DBUA"

\[
	A_{\phi} = (\Sigma \times \{0,1\}, Q_{\phi}, \init_{\phi}, \delta_{\phi}, F_{\phi})
\]

for $\phi(X)$, and another one

\[
	A_{\psi} = (\Sigma \times \{0,1\}, Q_{\psi}, \init_{\psi}, \delta_{\psi}, F_{\psi})
\]

for $\psi(Y)$.


We can now build a new "DBUA" $A = (\Sigma, \parts {Q_{\phi}} \times \parts {Q_{\psi}}, \init, \delta, F)$ where

\begin{itemize}
	\item$\begin{aligned}[t]
			      \init : \Sigma & \to      \parts {Q_{\phi}} \times \parts {Q_{\psi}} \\
			      a              & \mapsto  ( \init_{\phi}(a,*) , \init_{\psi}(a,*))
		      \end{aligned}$

	\item$\begin{aligned}[t]
			      \delta : (\parts {Q_{\phi}} \times \parts {Q_{\psi}})^2 \times \Sigma & \to      \parts {Q_{\phi}} \times \parts {Q_{\psi}}           \\
			      ((X,X'),(Y,Y'),a)                                                     & \mapsto (\delta_{\phi}(X,Y,(a,*)), \delta_{\psi}(X',Y',(a,*))
		      \end{aligned}$

	\item $F = \setdef {(X,X')} {(X \cap F_{\phi} \neq \emptyset) \ra (X' \cap F_{\psi} \neq \emptyset)}$
\end{itemize}

This automaton "accepts" a "tree" if and only if that "tree" is a model for $\Psi$. In particular, using the decision procedure
from \Cref{coro:univeral-Reach} we can decide if $\Psi$ is satisfied by all models, by checking  is $A$ is universal.

We are interested in finding an automaton that it is universal if and only if $\phi$ is "uniformisable". The approach we use consists on slightly modifying
the automaton for $\exists X. \phi(X) \ra \exists Y. \phi (Y)$ in a way that it guarantees that $Y$ is "definable".
`We will use the same construction as for $\Psi$ but modifying the "transition function".

\begin{definition}
	Let $\phi(X)$ a MSO formula, and $A =  (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ the "DBUA" for $\phi(X)$, we call $U = (\Sigma, \parts Q \times \parts Q,init_U, \deltau, F')$
	the ""uniformiser automaton"" of $\phi$, where
	\begin{itemize}
		\item$\begin{aligned}[t]
				      init_U : \Sigma & \to      \parts Q \times \parts {Q} \\
				      a               & \mapsto  ( \init(a,*), \init(a,*))
			      \end{aligned}$
		\item$\begin{aligned}[t]
				      \intro*\deltau : {\parts Q}^2 \times {\parts {Q}}^2 \times \Sigma & \to    {\parts {Q}}^2                           \\
				      ((X,X'),(Y,Y'),a)                                                 & \mapsto (\delta(X,Y,(a,*)), \deltauu (X',Y',a)) \\
			      \end{aligned}$
		\item $ \begin{aligned}[t]
				      \intro*\deltauu : \parts Q \times \parts Q \times \Sigma & \to \parts Q                                                                                                               \\
				      (X', Y', a)                                              & \mapsto \begin{cases}
					                                                                         \{\delta(p,p,(a,b))\}     \mid p \in X', a \in \Sigma, b \in \set{0,1}\} & \text{ if }  X = Y \text{ and } X' = Y' \\
					                                                                         \delta(X',Y',(a,*))                                                      & \text{ otherwise}
				                                                                         \end{cases}
			      \end{aligned}$
		\item $F' = \setdef {(X,X')} {(X \cap F \neq \emptyset) \ra (X' \cap F \neq \emptyset)}$
	\end{itemize}
\end{definition}


Intuitively, we want this automaton to check on the left if $\phi(X)$ is satisfiable and then build on the right side a
solution that is "definable". The way we ensure that the right side builds a "definable" solution is by restrictions its actions.
It will always build a solution for $\phi$, since it follows the transition of its automaton but, whenever it finds itself unable to
distinguish the left and the right trees, then it forces the state to be the same on on both sides, ensuring that there is no way of differentiating both sides on the
solution. On any other case, a solution would be "definable" since one can distinguish the left and the right by the shape of the tree.
Lets see a few examples: \todo{add examples}
\todo{add figures to better explain all of this}.

\begin{lemma}
	Let $\phi(X)$ be an MSO formula, if the "uniformiser automaton" $U$ of $\phi$ is "universal" then $\phi$ is "uniformisable".
\end{lemma}

\begin{proof}
	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$U = (\Sigma, \parts Q \times \parts Q,\init', \delta', F')$ the "uniformiser automaton" of $\phi$ is universal.
	We need to exhibit a "uniformiser" for $\phi(X)$.

	We first introduce a choice function $\intro*\choiceN : \parts Q \times \parts Q \times Q \times \Sigma \to Q \times Q \times \set{0,1}$
	that given $(X',Y',r,a)$ chooses a triple $(b,p,q)$ such that, if $r \in \deltauu(X',Y', a)$ then $\delta(p,q,(a,b)) = r$ where $p \in X', q \in Y'$
	and if $X' = Y'$ then $p = q$.
	We also introduce $\intro* \choiceL : Q \times \Sigma \to \set{0,1} $, which chooses
	$b$ such that $p = \init((a,b))$.
	Finally, we need to choose from a final state: $\intro* \choiceF : \parts Q \to  Q$ where
	$\choiceF (X) = q$ such that if $X \cap F \neq \emptyset$ then $q \in X \cap F$. If the premises are not satisfied in any of the cases, then
	these choice functions return an arbitrary value.

	We define the set $X_U$ and the "run" $\intro*\rhou$  by induction on the depth of the node as follows:
	\begin{itemize}
		\item For the root, we define $\rhou(\varepsilon) = \choiceF(\deltauu(t))$.
		\item For all inner nodes $x$ with children $y$ and $z$. Let $(p,q,v)$ be~$\choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), \rhou(x), \tlabel t x)$, we define
		      $\rhou(y)=p$, $\rhou(z)=q$, and $x \in X_U$ if and only if $b = 1$.
		\item For all "leaves" $x$, let $b$ be ~$b = \choiceL(p, \tlabel t x)$ we define $\rhou (x) = p$, where $x \in X_U$ if and only if $b = 1$.
	\end{itemize}

	We claim now that the $\rhou$ is well defined, unique, and a "run" of $A$ over $(t,X_U)$. The proof procedes by top-down induction.
	\begin{itemize}
		\item For $\varepsilon$, the "root" of $t$, we have that $\rhou(\varepsilon) = \choiceF(\deltauu(t))$, since $\choiceF$ is deterministic, $\rhou(\varepsilon)$ is unique.
		\item For the inner nodes $x$ with children $y$ and $z$, there exists $r \in Q$, such that $\rhou (x) = r$ by the induction hypothesis. Then,
		      since $\choiceN$ is deterministic, there exists a unique tuple $(p,q,b)$ such that $(p,q,b) = \choiceN(\deltauu(\subtree t y), \deltauu(\subtree t z), r, \tlabel t x)$.
		      We have that $\rhou(y) = p$ and $\rhou(z) = q$, which verify that $\delta(p,q,(\tlabel t x,b)) = r$. We also have that $x \in X_U$ \tiff $b = 1$. This is then a valid "run"
		      of $A$ over $(t,X_U)$
		\item For a "leaf" $x$ of "label" $a$, by the induction hypothesis we have that $b = \choiceL(a, \rhou(x))$ which is well defined since $a \in \Sigma$ and unique.
		      We also have that $x \in X$ \tiff $b = 1$ and $\rho(x) = \init ((a,b))$.
	\end{itemize}
	The claim is proved. In particular, this run satisfies the restrictions of $\deltauu$ and it's a run over the second projection of $U$.

	We are now ready to define a formula $\intro*\unif (X)$ that witnesses that $\phi$ is "uniformisable".
	This formula simply states using the MSO-syntax the existence of the run $\rhou$ described above, \ie,
	\[  t \models \unif(X) \text{ \tiff } X=X_U \]


	Given a set of "states" $P$, from \Cref{lem:MSO-aut} there exists a formula $\intro* \ustate_P(x)$ such that
	\todo{fix ustate ref}
	\[ t \models \ustate_P(x) \text{ if and only if } \deltauu(\subtree t x) = P .\]

	Let $k = \abs Q$.
	We define 5 subformulas :
	\begin{eqnarray*}
		\text{single\_state} (X_{p_1}, \ldots, X_{p_k})  &=& \forall x, \bigvee_{p_i \in \Nodes t} X_{p_i} (x)\\
		&\land& \forall x, \bigwedge_{p_i, p_j \in \Nodes t, i \neq j} \lnot(X_{p_i} (x) \land X_{p_j}(x))
	\end{eqnarray*}

	\begin{equation*}
		\text{root\_node} (X_{p_1}, \ldots, X_{p_k})  = \forall x, \treeroot(x) \ra (\bigvee_{p_i \in \choose \deltauu(\varepsilon)} X_{p_i}(x))
	\end{equation*}

	\begin{equation*}
		\text{in\_set} (X, x, b)  = (\bigwedge_{b = 1}  X(x)) \land (\bigwedge_{b = 0}  \lnot X(x))
	\end{equation*}

	\begin{equation*}
		\text{leaf\_node} (X_{p_1}, \ldots, X_{p_k})  = \forall x \left( \leaf(x) \rightarrow \bigvee_{\substack{(a, q) \in \init,\\ \choiceL(a,q) = b}} X_i(x) \land  \text{in\_set}(X,x,b)  \right)
	\end{equation*}

	\begin{eqnarray*}
		\text{inner\_nodes} (X_{p_1}, \ldots, X_{p_k}, X)  &=& \forall x \forall y, \forall z, \children (x,y,z) \ra \\
		&& \bigvee_{ \substack{(P',Q',a,R')\in \deltauu, \, r \in R', \\ \choiceN(P',Q',a,r) = (p,q,b)}} \Big( \ustate_{P'}(x) \land \ustate_{Q'}(y) \\
		&& \qquad \land \  X_p(x) \land X_q(y) \land a(z) \land X_r(z) \land  \text{in\_set}(X,x,b)\Big)
	\end{eqnarray*}


	We can now define $\unif(X)$:
	\begin{eqnarray*}
		\unif (X) &=& \exists X_{p_1}, \ldots, \exists X_{p_k}, \text{single\_state} (X_{p_1}, \ldots, X_{p_k}) \\
		&\land& \text{leaf\_node} (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \text{root\_node} (X_{p_1}, \ldots, X_{p_k})\\
		&\land& \text{inner\_nodes} (X_{p_1}, \ldots, X_{p_k}, X)
	\end{eqnarray*}
	$\unif(X)$ describes the run $\rhou$ over $(t,X_U)$ and has a unique solution, $X_U$.

	Let's show that $\unif(X)$ is a "uniformiser" for $\phi(X)$.
	If $U$ is universal the we have that, whenever $\phi(X)$ has a solution for a tree $t$, then there exists an accepting "run" $\rho$ of $U$ over $t$
	such that $\rho(\varepsilon) = (X,X')$ and such that $X \cap F \neq \emptyset$. Since the run is accepting $X' \cap F \neq \emptyset$, and we have that
	$\rhou$ is then well defined and $\unif(X)$ has a solution. Since $\rhou$ is a run of $A$, then we have that $X_U$ is also a solution of $\phi(X)$, so
	$\unif(X)$ is indeed a "uniformiser" for $\phi(X)$.

\end{proof}


\begin{lemma}
	Let $\phi(X)$ be and MSO formula, if $\phi(X)$ is "uniformisable" then the "uniformiser automaton" $U$ of $\phi(X)$ is "universal".
\end{lemma}

\begin{proof}
	We will prove it by contraposition.

	Let $A =  (\Sigma \times \{0,1\}, Q, \init, \delta, F)$ be the automaton for $\phi(X)$ and lets suppose that
	$U = (\Sigma, \parts Q \times \parts Q,\init', \delta', F')$ the "uniformiser automaton" of $\phi$ is not universal.
	We will show that $\phi(X)$ is not "uniformisable".

	Since $U$ is not "universal", there exists $(R,R') \in \Reach U$, such that $R \cap F \neq \emptyset$ and $R' \cap F = \emptyset$.
	We want to define a "tree" $t_{R,R'}$ such that
	\begin{enumerate}
		\item $R \subseteq \{ \delta_A (t_{R,R'},X) : X \subseteq \Nodes {t_{R,R'}}\}$ \label{lem:prop1}
		\item $\{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \subseteq R'$\label{lem:prop2}
		\item $\interpret U {t_{R,R'}} = (R,R')$\label{lem:prop3}
	\end{enumerate}

	Using \Cref{lem:def-aut}, if we prove that $\{ \delta_A (t_{R,R'},X) : \forall \sigma \in \Aut(t_{R,R'}), \sigma(X) = X\} \subseteq R'$ we also
	satisfy \ref{lem:prop2}.

	We prove by induction that $(T,T') \in \Reach U$ implies all of the three conditions.

	If $(T,T') = (\init(a,*). \init (a, *))$ for $a \in \Sigma$, then \ref{lem:prop1} and \ref{lem:prop3} are trivially satisfied and we have that
	$\Aut (a) = \{\text{id}\}$, so \ref{lem:prop2} is also satisfied.

	If $(T,T') = \delta_U((P,P'),(Q,Q'),a)$ for $a \in \Sigma$ and $P,P',Q,Q' \in \Reach U$, then by the induction hypothesis there exists
	$t_{P,P'}$ and $t_{Q,Q'}$ that verify the hypothesis. We can construct $t_{T,T'} = a(t_{P,P'},t_{Q,Q'})$. Lets prove that it satisfies the
	three properties.

	Lets begin by proving \ref{lem:prop3}.
	By definition of $\interpret U {\cdot}$,
	$\interpret U {t_{T,T'}} = \delta_U (\interpret U {t_{P,P'}}, \interpret U {t_{Q,Q'}}, a)$.
	If we use the induction hypothesis we deduce that
	$\delta_U (\interpret U {t_{P,P'}}, \interpret U {t_{Q,Q'}}, a) = \delta_U ((P,P'), (Q,Q'), a)$
	And by definition of $(T,T')$, $\delta_U ((P,P'), (Q,Q'), a) = (T,T')$.
	\ref{lem:prop3} is then verified.

	By definition, $T = \delta_A(P,Q,(a,*))$. Since by the induction hypothesis $P \subseteq \{ \delta_A (t_{P,P'},X) : X \subseteq \Nodes {t_{P,P'}}\}$
	and $Q \subseteq \{ \delta_A (t_{Q,Q'},X) : X \subseteq \Nodes {t_{Q,Q'}}\}$  we have that
	$T = \delta_A(P,Q,(a,*)) \subseteq \{ \delta_A (t_{T,T'},X) : X \subseteq \Nodes {t_{T,T'}}\}$. We have proven \ref{lem:prop1}.


	We will prove \ref{lem:prop2} by case distinction.
	Let $X \subseteq \Nodes {t_{P,P'}}$ such that $\forall \sigma \in \Aut (t_{T,T'}), \sigma(X) = X$, we introduce the
	sets $X_1 = X \cap \Nodes {t_{P,P'}}$ and $X_2 = X \cap \Nodes {t_{Q,Q'}}$.
	\begin{itemize}
		\item Lets suppose $P = Q$ and $P' = Q'$, in this case $t_{P,P'} \cong t_{Q,Q'}$. \todo{explain that it's because interpret is a function}
		      Let $\sigma$ be the automorphism over $\Nodes{T,T'}$ that swaps  $t_{P,P'}$ and $t_{Q,Q'}$.
		      We have that $\sigma (X) = X$. Since $\delta(X) = X$, $\delta$ must map $X_1$ to $X_2$, and the same is true for
		      $X_2$. So we have that $X_1 = X_2$ which means that $\delta(X_1) = X_1$. By construction we have that $p := \delta_A(t_{P,P'}, X_1) =  \delta_A(t_{Q,Q'}, X_2)$.
		      Using the induction hypothesis, we find that $p \in P'$ \todo{detail this}. So
		      $\delta_A (t_{T,T'}, X) = \delta_A(p,p,(a, X(\treeroot))) \in T'$. \todo{define $X(\treeroot)$.}

		\item Lets suppose $P' \neq Q'$ or $P \neq Q$, then $T' = \deltauu (P',Q',a) = \delta_a(P',Q',(a,*))$. We have to prove that
		      $\{ \delta_A (t_{T,T'},X) : \forall \sigma \in \Aut(t_{T,T'}), \sigma(X) = X\} \subseteq T'$.
		      Let $\sigma \in \Aut(t_{T,T'})$. Since $t_{P,P'} \ncong t_{Q,Q'}$, $\sigma$ cannot swap $t_{P,P'}$ and
		      $t_{P,P'}$ \todo{explain why}. Since we have that $\sigma(X) = X$, then we deduce that $\sigma(X_1) = X_1$ and
		      $\sigma(X_2) = X_2$ \todo{more details ?}. Let $p := \delta_A (t_{P,P'}, X_1)$ and $q := \delta_A (t_{Q,Q'}, X_2)$.
		      Using the induction hypothesis we deduce that $p \in P'$ and $q \in Q'$ \todo{Like in the previous case detail this?}.
		      So $\delta_A (t_{T,T'}, X) = \delta_A(p,q,(a, X(\treeroot))) \in T'$.
	\end{itemize}
	We have proved the three properties.

	Lets prove that  $\phi(X)$ is not "uniformisable" by exhibiting that no $X$ verifying $t_{R,R'} \models \phi(X)$ is "definable".
	Let $X \in F \cap \{ \delta_A (t_{R,R'},X) : X \subset \Nodes {t_{R,R'}}\}$, the intersection is not empty thanks to \ref{lem:prop1}. \todo{more details}
	We also know that $R' \cap F = \emptyset$ we can the deduce that $\{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \cap F = \emptyset$
	thanks to \ref{lem:prop2}. So we know that $X \notin \{ \delta_A (t_{R,R'},X) : X \ \text{"definable"}\} \cap F = \emptyset$ which means that no
	$X$ satisfying $t_{P,P'} \models \phi(X)$ is "definable". We deduce that $\phi(X)$ is not "uniformisable".
\end{proof}


\begin{theorem}
	Let $\phi(X)$ be an MSO formula, $\phi(X)$ is "uniformisable" if and only if the "uniformiser automaton" $U$ of $\phi(X)$ is "universal".
\end{theorem}

\begin{coro}
	\Cref{prob:uniformisation-problem} is decidable and we can construct its "uniformiser". \todo{reword this}
\end{coro}

\begin{proof}
	We can check if the "uniformiser automaton" of $\phi(X)$ is universal using \Cref{coro:univeral-Reach}. If the test successes,
	then we know that $\phi$ is "uniformisable" and its uniformiser is $\unif(X)$.
\end{proof}

\section{Conclusion}



\bibliographystyle{alpha}
\bibliography{tre-uniformisation}

\end{document}
