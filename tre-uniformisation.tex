\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}  
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{stmaryrd}

\usepackage{tikz-cd}
\usepackage{geometry}
\usepackage{hyperref}        

\usepackage[shortlabels]{enumitem}

\usepackage{fancyhdr}

\usepackage[hyperref]{knowledge}

\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}

\input{macros}

\input{tre-uniformisation.kl}

\begin{document}

\title{MSO uniformisation over trees}

\maketitle

\section{Trees}


\begin{definition}[Tree]
	A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$.
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are "trees".
	\end{itemize}

	The set of all "trees" over $\Sigma$ is $\tree_{\Sigma}$
\end{definition}

\begin{definition}[Nodes]
	The ""nodes"" of a "tree" are defined as follows:
	\[
		\nodes t = \begin{cases}
			\epsilon                                & \text{ if } t = a         \\
			\epsilon \cup \setdef {0u} {u \in \nodes {t'}}
			\cup \setdef {1u} {u \in \nodes {t''} } & \text{ if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}


\begin{definition}[Leaves]
	The ""leaves"" of a "tree" are defined as follows:
	\[
		\leaves t = \begin{cases}
			\epsilon                                 & \text{ if } t = a         \\
			\setdef {0u} {u \in \leaves {t'}}
			\cup \setdef {1u} {u \in \leaves {t''} } & \text{ if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}

\begin{remark}
	$\leaves t \subseteq \nodes t$
\end{remark}

\begin{definition}
	We note $\intro* \tlabel t n$ the ""label"" of the node $n$ in the "tree" $t$ :
	\[
		\tlabel t n =   \begin{cases}
			a               & \text{ if } t = a \text{ and } n = \epsilon         \\
			a               & \text{ if } t = a(t',t'') \text{ and } n = \epsilon \\
			\tlabel {t'} m  & \text{ if } t = a(t',t'') \text{ and } n = 0m       \\
			\tlabel {t''} m & \text{ if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}


\begin{definition}
	We note $\intro* \tnode t n$ the subtree corresponding to the node $n$ in the "tree" $t$ :
	\[
		\tnode t n =   \begin{cases}
			t              & \text{ if }  n = \epsilon                     \\
			\tnode {t'} m  & \text{ if } t = a(t',t'') \text{ and } n = 0m \\
			\tnode {t''} m & \text{ if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}

\begin{definition}
	Let $t$ be a "tree" and $x, y \in \nodes t$, we define the ""ancestor"" relation as
	\[ \ancestor x y \iff \exists z \in \nodes t, y = xz \]
\end{definition}



\section{Tree Automata}

\begin{definition}[""Non-Deterministic Bottom-Up Tree automaton""]
	A Non-Deterministic Bottom-Up Tree automaton (NBUA) is defined as a tuple
	$(\Sigma, Q, I, \Delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of states.
		\item $I \subseteq \Sigma \times Q$ correspond to the possible states of the leaves.
		\item $\Delta \subseteq Q \times Q \times \Sigma \times Q$ are the transitions.
		\item $F \subseteq Q$ is the set of final states.
	\end{itemize}
\end{definition}

\begin{definition}[Execution of an automaton]
	An ""run"" $\intro* \exec$ of a "NBUA" $A$ over a "tree" $t$ is :

	\begin{eqnarray*}
		\exec : \nodes t &\to& Q \\
		(\tlabel t b,  \exec (n) ) \in I &\text{ if }& n \in \leaves t \\
		(\exec (n0), \exec (n1), \tlabel t n, \exec (n)) \in \Delta &\text{ if }& n \in \nodes t \setminus \leaves t
	\end{eqnarray*}

	We say that $\exec$ is ""acceptant"" if $\exec (\epsilon) \in F$ and $A$ "accepts" $t$ if
	$F \cap \setdef { q\in Q} {\exec (\epsilon) = q} \neq \emptyset$
\end{definition}


\begin{definition}[Language of an automaton]
	Let $A$ be a "NBUA". Its ""associated language"" is defined as:
	\[\lang A = \setdef {t \in \tree_{\Sigma}} {\exists \exec,  \exec (\epsilon) \in F}\]
\end{definition}


\begin{definition}[""Deterministic Bottom-Up Tree automaton""]
	A Deterministic Bottom-Up Tree automaton (DBUA) is "NBUA" that that verifies
	\[ \forall q,r,a,t,t' \ (q,r,a,t) \in \Delta \land   (q,r,a,t') \in \Delta  \implies t = t' \]
\end{definition}

\begin{remark}
	A "DBUA" can also be defined as as a tuple $(\Sigma, Q, \text{init}, \delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of states.
		\item $\intro *\init : \Sigma \to Q$ is a function that initializes the states of the leaves.
		\item $\delta : Q \times Q \times \Sigma \to Q$ is the transition function.
		\item $F \subseteq Q$ is the set of final states.
	\end{itemize}
	We will show that the two definitions are equivalent.
\end{remark}

\begin{definition}[Interpretation of an automaton]
	The ""interpretation"" of a "DBUA" $A$,  $\intro* \interpret A ~$, over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\interpret A ~: \tree_{\Sigma} &\to& Q \\
		a &\mapsto& \init_a \\
		a(t,t') &\mapsto& \delta_a (\interpret A t, \interpret A {t'})
	\end{eqnarray*}
\end{definition}

\begin{remark}
	In the case of a "DBUA" there exists a unique "run" that corresponds to :

	\begin{eqnarray*}
		\exec : \nodes t &\to & Q \\
		n  &\mapsto& \init_{\tlabel t n} \text{ if } n \in \leaves t \\
		n  &\mapsto& \delta_{\tlabel t n}(\exec (n0), \exec (n1)) \text{ if } n \in \nodes t \setminus \leaves t
	\end{eqnarray*}
\end{remark}

\begin{lemma}\label{lem:exec-sub}
	For a "DBUA" $A$, for any "run" $\exec$ over a "tree" $t$, and for any node $n \in \nodes t$, there exists $\exec'$ over
	$\tnode t n$ such that $\exec (n) = \exec'(\epsilon)$.
\end{lemma}

\begin{proof}
	\todo{~}
\end{proof}

\begin{lemma}
	Let $A$ be a "DBUA",
	\[ \lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A t \in F} \]
\end{lemma}

\begin{proof}
	We will prove by induction on a "tree"~$t$ that (a) there exists a "run" of~$A$ over~$t$, and (b) for all "runs"~$\exec$ of $A$ over $t$, $\interpret A t = \exec (\epsilon)$. 
	We proceed by case distinction.
	\begin{itemize}
		\item If $t = a$. Let $\rho$ be defined by $\rho(\varepsilon)=\init_a$, then $\rho$ is a "run" of~$A$ over~$t$. We have proved (a).
			Consider now some "run" $\rho$ of $A$ over~$t$. We have $\rho(\epsilon)=\init_a=\interpret A a=\interpret A t$. We have proved  (b).	
%		      $\interpret A t = \interpret A a = \init_a = \init_{\tlabel t {\epsilon}} = \exec (\epsilon)$
		\item If $t = a(t',t'')$. By induction hypothesis (a), there exists "runs"~$\rho'$ and $\rho''$ on~$t'$ and $t''$ respectively.
			Let~$\rho$ be defined by $\rho(\epsilon)=\delta_{t(\epsilon)}(\rho'(\epsilon),\rho''(\epsilon))$,
			$\rho(0u)=\rho'(u)$ for all $u\in\nodes{t'}$ and $\rho(1u)=\rho''(u)$ for all~$u\in \nodes{t''}$. Then $\rho$ is a "run" of~$A$ over $t$. We have proved (a).
			Consider now some~$run$ $\rho$ of $A$ over $t$. Let~$\rho'(u)=\rho(0u)$ for all ... and $\rho''()$ ...,
			then $\rho'$ is a "run" of~$A$ over $t'$ and $\rho''$ over $t''$. By induction hypothesis (b) twice, we know that $\rho'(\epsilon)=\interpret A {t'}$ and $\rho''(\epsilon)=\interpret A {t''}$.
			We have now $\rho(\epsilon) = \delta_{t(\epsilon)}(\rho'(\epsilon),\rho''(\epsilon)) = \delta_{t(\epsilon)}(\interpret A {t'},\interpret A {t''}) = \interpret A t$. We have proved (b).
	\end{itemize}
	\todo{discuss this proof with Thomas.}
\end{proof}

\begin{theorem}
	Let $N$ be a "NBUA", the "DBUA"
	\[
		D = (\Sigma, \parts Q, \text{init}, \delta, F' )
	\]
	where:

	\begin{itemize}
		\setlength{\itemsep}{0pt} % Reduce spacing between items
		\item $ \init : \Sigma \to \parts Q, \quad a \mapsto \setdef{q \in Q}{(a,q) \in I}. $
		\item $ \delta : \Sigma \times \parts Q \times \parts Q \to \parts Q, \quad (X, Y, a) \mapsto \setdef{q \in Q}{(x,y,a,q) \in \Delta, x \in X, y \in Y}. $
		\item $ F' = \setdef{X \in \parts Q}{X \cap F \neq \emptyset} \subseteq \parts Q. $
	\end{itemize}

	This verifies
	\[
		\lang N = \lang D.
	\]
\end{theorem}

\begin{proof}
	We will show that for any "tree" $t$,
	\[ 
		\interpret D t = \setdef {\rho(\epsilon)}{\text{$\rho$ "run" of~$N$ over~$t$}}\ .
	 \]
	The proof proceeds by induction on the structure of "trees".
	\begin{itemize}
		\item If $t = a$, then
		      \begin{eqnarray*}
			      \setdef {q \in Q} {\exists \exec, \exec (\epsilon) = q} &=&  \setdef {q \in Q} {(a,q) \in I} \\
			      &=& \interpret D t\ .
		      \end{eqnarray*}
		\item $(t = a(t_1,t_2))$\\
		      By induction we know that
		      $\interpret D {t_i} = q_i$ iff there exists a "run" over $t_i$ ending at $q_i$, for $i \in \set {1,2}$.

		      \begin{eqnarray*}
			      &&q \in \interpret D t \\
			      &\text{if and only if}& \delta_a (\interpret D {t_1}, \interpret D {t_2}) \\
			      &\text{if and only if}& \setdef {q \in  Q} {(x_1,x_2,a,q) \in \Delta, x_1 \in \interpret D {t_1}, x_2 \in \interpret D {t_2}} \\
			      &\text{if and only if}& \exists x_1,x_2, (x_1,x_2,a,q) \in \Delta, x_1 \in \interpret D {t_1}, x_2 \in \interpret D {t_2} \\
			      &\text{if and only if}& \text{there exists a "run" over }  t_i  \text { ending at } x_i \text { for  } i \in \set {1,2} \text{ and } (x_1,x_2,a,q) \in \Delta\\
			      &\text{if and only if}& \exists \exec, \exec (\epsilon) = q
		      \end{eqnarray*}
	\end{itemize}
	Then $ \interpret A t = \setdef {q \in Q} {\exists \exec, \exec (\epsilon) = q} $.

	We must now show that $D$ "accepts" $t$ iff $N$ "accepts" $t$.

	\begin{eqnarray*}
		N \text{ "accepts" } t &\iff& F \cap \setdef {q \in Q} {(a,q) \in I} \neq \emptyset \\
		&\iff&   F \cap  \interpret D t \neq \emptyset \\
		&\iff& \interpret D t  \in F' \\
		&\iff& D \text{ "accepts" } t
	\end{eqnarray*}

	and so $\lang N = \lang D$.

	\todo{Discuss proof}
\end{proof}


\begin{definition}
	An "NBUA" of "transition relation"~$\Delta$ is ""order-insensitive"" if for all "transitions" $(p,q,a,r) \in \Delta$,
	$(q,p,a,r) \in \Delta$.
\end{definition}

\begin{remark}
	For a "DBUA" of "transition map"~$\delta$, it is "order-insensitive" if and only if 
	$\delta_a (p,q) = \delta_a (q,p)$ for all "states"~$p,q$ and letter~$a$.
\end{remark}

\begin{lemma}
	If $N$ a "NBUA" is "order-insensitive", then it's corresponding deterministic automaton is also "order-insensitive".
\end{lemma}

\begin{proof}
	Let $D$ be the deterministic automaton corresponding to $N$.
	\begin{eqnarray*}
		\delta_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \Delta, x \in X, y \in Y}  \reason {$N$ is "order-insensitive"} \\
		&=& \delta_a (Y,X)
	\end{eqnarray*}
\end{proof}

\subsection{MSO}

\begin{lemma}
	If $A$ is a "order-insensitive" "NBUA"  then there exists a MSO formula $\phi$ such that for all $t \in \tree_{\Sigma}$,
	\[ M(t) \models \phi \iff t \in \lang A \]
	\todo{Write up all of the missing definitions}
\end{lemma}

\begin{proof}
	Let $A$ be a "NBUA", and $k = \abs Q$.

	We define the following formulas:
	\begin{itemize}
		\item We can encode the fact that $ x $ is a "leaf" as follows :
		      \[\text{leaf} (x) = \forall y, \ancestor y x \]
		\item $x$ is the root of the tree is equivalent to :
		      \[\text{root} (x) = \forall y, \ancestor x y \]
		\item The following formula encodes the fact that $ x $ and $y$ are the immediate children of $z$:
		      \[\text{children} (x,y,z) =
			      x \neq y \land
			      \ancestor z x \land \ancestor z y \land
			      \forall w
			      \left(
			      \left(
				      \ancestor z w \land
					      (\ancestor w x \lor \ancestor w y) \right) \rightarrow (
				      w = x \lor w = y
				      )
			      \right) \]
		\item $F_i$ is the set of all "labels" leading to a final state:
		      \[F_i = \setdef {a \in \Sigma} {(i0,i1,a,i) \in \Delta, i \in F}\]
	\end{itemize}

	\begin{eqnarray}
		\phi = \exists X_0 \ldots \exists X_{k-1} &\ & \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \label{lem:AMSO1}\\
		&\land& \forall x \left( \bigwedge_{0 \leq i \leq j \leq k-1}  \lnot (X_i(x) \land X_j(x)) \right) \label{lem:AMSO2} \\
		&\land& \forall x  \left( \text{leaf} (x) \ra \bigvee_{(a,i)\in I}  X_i(x) \right) \label{lem:AMSO3}\\
		&\land& \forall x \forall y \forall z \left(\text{children}(x,y,z) \ra \bigvee_{(i,j,a,k)\in \Delta} \left(X_i(x) \land X_j(y) \land a(z) \land X_k(z)\right)\right) \label{lem:AMSO4} \\
		&\land& \forall x \left(\text{root}(x) \ra \bigwedge_{i= 0}^k \left( X_i(x) \ra \bigvee_{a \in F_i} a(x) \right)\right) \label{lem:AMSO5}
	\end{eqnarray}

	\todo{fix overfull}

	$j \in X_i$ iff, for a given run, the state $i$ is reached from the node $j$.

	The formula $\phi$ encodes the following properties:

	\begin{enumerate}
		\item Every node has an associated state.
		\item A node cannot be in two states at the same time.
		\item The transitions originate from the leaves.
		\item The transitions of inner nodes ensure that for every trio of nodes, where two are children of the third, there exists a transition from the children to the parent.
		\item Finally, the word is accepted if and only if the state associated with the root node is a final state.
	\end{enumerate}

	From this we deduce that
	\[ M(t) \models \phi \iff t \in \lang A \]
\end{proof}


\iffalse
	\bibliographystyle{alpha}
	\bibliography{tre-uniformisation}
\fi

\end{document}
