\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}  
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{mathtools}

\usepackage{tikz-cd}
\usepackage{geometry}
\usepackage{hyperref}        

\usepackage[shortlabels]{enumitem}

\usepackage{fancyhdr}

\usepackage[hyperref,paper]{knowledge}

\usepackage{tre-uniformisation}

\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}


\knowledge{tree}{notion}
\knowledge{Deterministic Bottom-Up Tree automaton}[DFTA]{notion}
\knowledge{Non-Deterministic Bottom-Up Tree automaton}[NFTA]{notion}
\knowledge{interpretation}{notion}
\knowledge{associated language}[lang]{notion}
\knowledge{nodes}{notion}
\knowledge{leaves}{notion}
\knowledge{label}{notion}
\knowledge{ancestor}{notion}
\knowledge{execution}[exec]{notion}
\knowledge{init}{notion}
\knowledge{order-invertible}{notion}
\knowledge{acceptant}{notion}


\begin{document}

\title{Uniformisation de MSO sur les arbres}

\maketitle

\section{Definitions}


\begin{definition}[Tree]
	A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$.
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are trees.
	\end{itemize}
\end{definition}

\begin{definition}[Nodes]
	The ""nodes"" of a $\tree$ are defined as follows:
	$$
		\nodes t = \left\{  \begin{array}{cc}
			\epsilon                                & \text{ if } t = a         \\
			\epsilon \cup \setdef {0u} {u \in \nodes {t'}}
			\cup \setdef {1u} {u \in \nodes {t''} } & \text{ if } t = a(t',t'')
		\end{array}
		\right.
	$$
\end{definition}


\begin{definition}[Leaves]
	The ""leaves"" of a $\tree$ are defined as follows:
	$$
		\leaves t = \left\{  \begin{array}{cc}
			\epsilon                                 & \text{ if } t = a         \\
			\setdef {0u} {u \in \leaves {t'}}
			\cup \setdef {1u} {u \in \leaves {t''} } & \text{ if } t = a(t',t'')
		\end{array}
		\right.
	$$
\end{definition}

\begin{remark}
	$\leaves t \subseteq \nodes t$
\end{remark}


\begin{notation}
	We note $\tlabel t n$ the ""label"" of the node $n$ in the tree $t$ :
	$$
		\tlabel t n = \left\{  \begin{array}{cc}
			a               & \text{ if } t = a \text{ and } n = \epsilon         \\
			a               & \text{ if } t = a(t',t'') \text{ and } n = \epsilon \\
			\tlabel {t'} m  & \text{ if } t = a(t',t'') \text{ and } n = 0m       \\
			\tlabel {t''} m & \text{ if } t = a(t',t'') \text{ and } n = 1m
		\end{array}
		\right.
	$$
\end{notation}

\begin{definition}
	Let $t$ be a $\tree$ and $x, y \in \nodes t$, we define the ""ancestor"" relation as
	$$ \ancestor x y \iff \exists z \in \nodes t, y = xz$$
\end{definition}

\begin{definition}[""Deterministic Bottom-Up Tree automaton""]
	A Deterministic Bottom-Up Tree automaton (DFTA) is defined as a tuple:
	$$ (\Sigma, Q, \text{init} : \Sigma \to Q, \delta : \Sigma \times Q \times Q \to Q, F) $$
	where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of states.
		\item ""init"" is a function that initializes the states of the leaves.
		\item $\delta$ is the transition function.
		\item $F$ is the set of final states.
	\end{itemize}
\end{definition}

\begin{definition}[""Non-Deterministic Bottom-Up Tree automaton""]
	A Non-Deterministic Bottom-Up Tree automaton (NFTA) is defined as a tuple:
	$$ (\Sigma, Q, I \subseteq \Sigma \times Q, \Delta \subseteq Q \times Q \times \Sigma \times Q, F \subseteq Q) $$
\end{definition}

\begin{definition}[Interpretation of an automaton]
	The ""interpretation"" of an automaton $A$ over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\interpret A : \tree_{\Sigma} &\to& Q \\
		\interpret A (a) &=& \text{init}_a \\
		\interpret A (a(t,t')) &=& \delta_a (\interpret A (t), \interpret A (t'))
	\end{eqnarray*}
	\todo{extend definition to NFTA ?}
\end{definition}

\begin{definition}[Language of an automaton]
	Let $A$ be a "DFTA". Its ""associated language"" is defined as:
	$$\lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A (t) \in F}$$
\end{definition}


\begin{definition}[Execution of an automaton]
	The ""execution"" of a "DFTA" $A$ over a $\tree$ $t$ is :

	\begin{eqnarray*}
		\exec A : \nodes t &\to & Q \\
		\exec A (n)  &=& \init_{\tlabel t n} \text{ if } n \in \leaves t \\
		\exec A (n)  &=& \delta_{\tlabel t n}(\exec A (n0), \exec A (n1)) \text{ if } n \in \nodes t \setminus \leaves t
	\end{eqnarray*}

	We say that $\exec A$ is ""acceptant"" if $\exec A (\epsilon) \in F$.

	In the case of a "NFTA" :

	\begin{eqnarray*}
		\exec A : \nodes t &\to& \parts Q \\
		(\tlabel t b,  \exec A (n)) \in I &\text{ if }& n \in \leaves t \\
		(\exec A (n0), \exec A (n1), \tlabel t n, \exec A (n)) \in \Delta &\text{ if }& n \in \nodes t \setminus \leaves t
	\end{eqnarray*}

	We say that $\exec A$ is "acceptant" if $\exists f \in F, f \in \exec A (\epsilon)$.

	\todo{Improve the NFTA definition}
\end{definition}

\begin{lemma}
	For a "NFTA", $N$, for any tree $t = a(t',t'')$,
	$\exec N (0) = \exec N (\epsilon_{t'})$
	and
	$\exec N (1) = \exec N (\epsilon_{t''})$.
\end{lemma}

\begin{remark}
	Let $A$ be a "DFTA",
	$$ \lang A = \setdef {t \in \tree_{\Sigma}} {\exec A (\epsilon) \in F} $$
\end{remark}

\begin{proof}
	We will proof that for any $\tree \ t$, $\interpret A (\tlabel t {\epsilon}) = \exec A (\epsilon)$.
	The proof procedes by induction on the structure of trees.
	\begin{itemize}
		\item $t = a$. Then
		      $\interpret A (\tlabel t {\epsilon}) = \interpret A (a)=  \init_a = \init_{\tlabel t {\epsilon}} = \exec A (\epsilon)$
		\item $t = a(t',t'')$. Then
		      \begin{eqnarray*}
			      \exec A (\epsilon)  &=& \delta_{\tlabel t {\epsilon}}(\exec A (0), \exec A (1)) \\
			      &=& \delta_a (\exec A (0), \exec A (1)) \\
			      &=& \delta_a (\exec A (\epsilon_{t'}), \exec A (\epsilon_{t''})) \\
			      &=& \delta_a (\interpret A (t'), \interpret A (t'')) \\
			      &=& \interpret A (t)
		      \end{eqnarray*}
	\end{itemize}
	\todo{reread this proof carefully and discuss it with Thomas.}
\end{proof}

\begin{theorem}
	Let $N$ be a "NFTA", there exists a "DFTA", $D$, such that
	$$\lang N = \lang D$$
\end{theorem}

\begin{proof}
	We consider the automaton
	$$ D = (\Sigma, \parts Q, \text{init} : \Sigma \to \parts Q, \delta : \Sigma \times \parts Q \times \parts Q \to \parts Q, F' \subseteq \parts Q) $$
	where
	\begin{itemize}
		\item $\init (a) = \setdef {q \in Q} {(a,q) \in I}$
		\item $\delta (a, X, Y) = \setdef {q \in  Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y}$
		\item $F' = \setdef {X \in \parts Q} {X \cap F \neq \emptyset}$
	\end{itemize}

	We will show that for any tree $t$,
	$$ \exec D (\epsilon)  = \exec N (\epsilon)$$
	The proof proceeds by induction on the structure of trees.
	\begin{itemize}
		\item $(t = a)$\\
		      In this case, $\exec D (\epsilon) = \setdef {q \in Q} {(a,q) \in I}$ which corresponds
		      exactly with $\exec N (\epsilon)$.

		\item $(t = a(t',t''))$\\
		      By induction we know that
		      $\exec D (\epsilon_{t'}) = \exec N ({\epsilon_{t'}})$
		      and
		      $\exec D (\epsilon_{t''}) =  \exec N ({\epsilon_{t''}})$

		      \begin{eqnarray*}
			      \exec D (\epsilon) &=& \delta_a(\exec D (0), \exec D (1)) \\
			      &=& \setdef {q \in  Q} {(x,y,a,q) \in \Delta, x \in \exec D (0), y \in \exec D (1)}\\
			      &=& \setdef {q \in  Q} {(x,y,a,q) \in \Delta, x \in \exec N ({\epsilon_{t'}}), y \in \exec N ({\epsilon_{t''}})}\\
			      &=& \setdef {q \in  Q} {(x,y,a,q) \in \Delta, x \in \exec N (0), y \in \exec N (1)}\\
			      &=& \exec N (\epsilon)
		      \end{eqnarray*}
	\end{itemize}
	Then $ \exec D (\epsilon)  = \exec N (\epsilon)$.


	We must now show that $D$ is "acceptant" iff $N$ is "acceptant".

	\begin{eqnarray*}
		N \text{ is "acceptant" } &\iff& F \cap \exec N (\epsilon) \neq \emptyset \\
		&\iff& F \cap \exec D (\epsilon) \neq \emptyset \\
		&\iff& \exec D (\epsilon) \in F' \\
		&\iff& D \text{ is "acceptant" }
	\end{eqnarray*}

	and so $\lang N = \lang D$.

	\todo{Discuss proof}
\end{proof}


\begin{definition}
	We say that an automaton is ""order-invertible"" if
	$$ \forall p,q,a,\, \delta_a (p,q) = \delta_a (q,p) $$ et
	and for the non deterministic ones
	$$ \forall p,q,a,r,\, (p,q,a,r) \in \Delta \iff  (q,p,a,r) \in \Delta $$

	\todo{discuss this name with Thomas}
\end{definition}


\begin{lemma}
	If $N$ a "NFTA" is "order-invertible", then it's corresponding deterministic automaton is also "order-invertible".
\end{lemma}

\begin{proof}
	Let $D$ be the deterministic automaton corresponding to $N$.
	\begin{eqnarray*}
		\delta_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \Delta, x \in X, y \in Y}  \reason {$N$ is "order-invertible"} \\
		&=& \delta_a (Y,X)
	\end{eqnarray*}
\end{proof}

\begin{theorem}
	If $A$ is a "order-invertible" "NFTA"  then there exists an MSO formula $\phi$ such that for all $\tree_{\Sigma} \ t$,
	$$ M(t) \models \phi \iff t \in \lang A$$
	\todo{Write up all of the missing definitions}
\end{theorem}

\begin{proof}
	Let $A$ be a "NFTA", and $k = \abs Q$.
	$$\text{leaf} (x) = \forall y, \ancestor y x$$
	$$\text{top} (x) = \forall y, \ancestor x y$$
	$$F_i = \setdef {a \in \Sigma} {(i0,i1,a,i) \in \Delta, i \in F}$$


	\begin{eqnarray*}
		\phi = \exists X_0,\ldots, \exists X_{k-1} &\ & \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \\
		&\land& \forall x \left( \text{leaf} (x) \ra \bigvee_{(a,i)\in I}  X_i(x)   \right) \\
		&\land& \forall x \left(\lnot \text{leaf}(x) \ra \bigvee_{(i,j,a,k)\in \Delta}  \left(X_i(x0) \land X_j(x1) \land a(x) \land X_k(x)\right)\right) \\
		&\land& \forall x \left(\text{top}(x) \ra \bigwedge_{i= 0}^k \left( X_i(x) \ra \bigvee_{a \in F_i} a(x) \right)\right)
	\end{eqnarray*}


	\todo {Write actual proof}
\end{proof}



\bibliographystyle{alpha}
\bibliography{tre-uniformisation}

\end{document}
