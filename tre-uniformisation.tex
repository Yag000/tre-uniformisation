\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb} 
\usepackage{amsthm}  
\usepackage{dsfont}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{stmaryrd}

\usepackage{tikz-cd}
\usepackage{geometry}
\usepackage{hyperref}        

\usepackage[shortlabels]{enumitem}

\usepackage{fancyhdr}

\usepackage[hyperref,paper]{knowledge}

\knowledgeconfigure{label scope=false, notion, quotation, protect quotation={tikzcd, automata}}

\input{macros}

\input{tre-uniformisation.kl}

\begin{document}

\title{Uniformisation de MSO sur les arbres}

\maketitle

\section{Trees}


\begin{definition}[Tree]
	A ""tree"" over an alphabet $\Sigma$ is recursively defined as follows:
	\begin{itemize}
		\item $a$, where $a \in \Sigma$.
		\item $a(t,t')$, where $a \in \Sigma$ and $t, t'$ are "trees".
	\end{itemize}

	The set of all "trees" over $\Sigma$ is $\tree_{\Sigma}$
\end{definition}

\begin{definition}[Nodes]
	The ""nodes"" of a "tree" are defined as follows:
	\[
		\nodes t = \begin{cases}
			\epsilon                                & \text{ if } t = a         \\
			\epsilon \cup \setdef {0u} {u \in \nodes {t'}}
			\cup \setdef {1u} {u \in \nodes {t''} } & \text{ if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}


\begin{definition}[Leaves]
	The ""leaves"" of a "tree" are defined as follows:
	\[
		\leaves t = \begin{cases}
			\epsilon                                 & \text{ if } t = a         \\
			\setdef {0u} {u \in \leaves {t'}}
			\cup \setdef {1u} {u \in \leaves {t''} } & \text{ if } t = a(t',t'')
		\end{cases}
	\]
\end{definition}

\begin{remark}
	$\leaves t \subseteq \nodes t$
\end{remark}

\begin{definition}
	We note $\intro* \tlabel t n$ the ""label"" of the node $n$ in the "tree" $t$ :
	\[
		\tlabel t n =   \begin{cases}
			a               & \text{ if } t = a \text{ and } n = \epsilon         \\
			a               & \text{ if } t = a(t',t'') \text{ and } n = \epsilon \\
			\tlabel {t'} m  & \text{ if } t = a(t',t'') \text{ and } n = 0m       \\
			\tlabel {t''} m & \text{ if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}


\begin{definition}
	We note $\intro* \tnode t n$ the subtree corresponding to the node $n$ in the "tree" $t$ :
	\[
		\tnode t n =   \begin{cases}
			t              & \text{ if }  n = \epsilon                     \\
			\tnode {t'} m  & \text{ if } t = a(t',t'') \text{ and } n = 0m \\
			\tnode {t''} m & \text{ if } t = a(t',t'') \text{ and } n = 1m
		\end{cases}
	\]
\end{definition}

\begin{definition}
	Let $t$ be a "tree" and $x, y \in \nodes t$, we define the ""ancestor"" relation as
	\[ \ancestor x y \iff \exists z \in \nodes t, y = xz \]
\end{definition}

\section{Tree Automata}

\begin{definition}[""Deterministic Bottom-Up Tree automaton""]
	A Deterministic Bottom-Up Tree automaton (DBUA) is defined as a tuple $(\Sigma, Q, \text{init}, \delta, F)$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of states.
		\item $\intro *\init : \Sigma \to Q$ is a function that initializes the states of the leaves.
		\item $\delta : Q \times Q \times \Sigma \to Q$ is the transition function.
		\item $F \subseteq Q$ is the set of final states.
	\end{itemize}
\end{definition}

\begin{definition}[Interpretation of an automaton]
	The ""interpretation"" of a "DBUA" $A$,  $\intro* \interpret A ~$, over an alphabet $\Sigma$ is defined as follows:
	\begin{eqnarray*}
		\interpret A ~: \tree_{\Sigma} &\to& Q \\
		a &\mapsto& \init_a \\
		a(t,t') &\mapsto& \delta_a (\interpret A t, \interpret A {t'})
	\end{eqnarray*}
\end{definition}


\begin{definition}[Language of an automaton]
	Let $A$ be a "DBUA". Its ""associated language"" is defined as:
	\[\lang A = \setdef {t \in \tree_{\Sigma}} {\interpret A t \in F}\]
\end{definition}

\begin{definition}[""Non-Deterministic Bottom-Up Tree automaton""]
	A Non-Deterministic Bottom-Up Tree automaton (NBUA) is defined as a tuple
	$(\Sigma, Q, I \subseteq, \Delta , F )$ where:
	\begin{itemize}
		\item $\Sigma$ is an alphabet.
		\item $Q$ is a finite set of states.
		\item $I \subseteq \Sigma \times Q$ correspond to the possible states of the leaves.
		\item $\Delta \subseteq Q \times Q \times \Sigma \times Q$ are the transitions.
		\item $F \subseteq Q$ is the set of final states.
	\end{itemize}
\end{definition}


\begin{definition}[Execution of an automaton]
	An ""run"" $\intro* \exec$ of a "NBUA" $A$ over a "tree" $t$ is :

	\begin{eqnarray*}
		\exec : \nodes t &\to& Q \\
		(\tlabel t b,  \exec (n) ) \in I &\text{ if }& n \in \leaves t \\
		(\exec (n0), \exec (n1), \tlabel t n, \exec (n)) \in \Delta &\text{ if }& n \in \nodes t \setminus \leaves t
	\end{eqnarray*}

	We say that $\exec$ is ""acceptant"" if $F \cap \exec (\epsilon) \neq \emptyset$ and $A$ "accepts" $t$ if
	$F \cap \setdef { q\in Q} {\exec (\epsilon) = q} \neq \emptyset$
\end{definition}

\begin{remark}
	In the case of a "DBUA" there exists a unique "run" that corresponds to :

	\begin{eqnarray*}
		\exec : \nodes t &\to & Q \\
		n  &\mapsto& \init_{\tlabel t n} \text{ if } n \in \leaves t \\
		n  &\mapsto& \delta_{\tlabel t n}(\exec (n0), \exec (n1)) \text{ if } n \in \nodes t \setminus \leaves t
	\end{eqnarray*}
\end{remark}

\begin{lemma}\label{lem:exec-sub}
	For a "DBUA" $A$, for any "run" $\exec$ over a "tree" $t$, and for any node $n \in \nodes t$, there exists $\exec'$ over
	$\tnode t n$ such that $\exec (n) = \exec'(\epsilon)$.
\end{lemma}

\begin{proof}
	\todo{}
\end{proof}

\begin{lemma}
	Let $A$ be a "DBUA",
	\[ \lang A = \setdef {t \in \tree_{\Sigma}} {\exec (\epsilon) \in F} \]
\end{lemma}

\begin{proof}
	We will proof that for any tree "tree" $t$, $\interpret A t = \exec (\epsilon)$.
	The proof procedes by induction on the structure of "trees".
	\begin{itemize}
		\item $t = a$. Then
		      $\interpret A t = \interpret A a = \init_a = \init_{\tlabel t {\epsilon}} = \exec (\epsilon)$
		\item $t = a(t',t'')$. Then
		      \begin{eqnarray*}
			      \exec (\epsilon)  &=& \delta_{\tlabel t {\epsilon}}(\exec (0), \exec (1)) \\
			      &=& \delta_a (\exec (0), \exec (1)) \\
			      &=& \delta_a (\exec' (\epsilon), \exec''  (\epsilon))  \reason{\ref{lem:exec-sub}}\\
			      &=& \delta_a (\interpret A {t'}, \interpret A {t''}) \reason{I.H.}\\
			      &=& \interpret A t
		      \end{eqnarray*}
	\end{itemize}
	\todo{discuss this proof with Thomas.}
\end{proof}

\begin{theorem}
	\begin{theorem}
		Let $N$ be a "NBUA", the "DBUA"
		\[
			D = (\Sigma, \parts Q, \text{init}, \delta, F' )
		\]
		where:

		\begin{itemize}
			\setlength{\itemsep}{0pt} % Reduce spacing between items
			\item $ \init : \Sigma \to \parts Q, \quad a \mapsto \setdef{q \in Q}{(a,q) \in I}. $
			\item $ \delta : \Sigma \times \parts Q \times \parts Q \to \parts Q, \quad (X, Y, a) \mapsto \setdef{q \in Q}{(x,y,a,q) \in \Delta, x \in X, y \in Y}. $
			\item $ F' = \setdef{X \in \parts Q}{X \cap F \neq \emptyset} \subseteq \parts Q. $
		\end{itemize}

		This verifies
		\[
			\lang N = \lang D.
		\]
	\end{theorem}
\end{theorem}

\begin{proof}
	We will show that for any "tree" $t$,
	\[ \interpret D t = \setdef {q \in Q} {\exists \exec, \exec (\epsilon) = q} \]
	The proof proceeds by induction on the structure of "trees".
	\begin{itemize}
		\item $(t = a)$\\
		      In this case
		      \begin{eqnarray*}
			      \setdef {q \in Q} {\exists \exec, \exec (\epsilon) = q} &=&  \setdef {q \in Q} {(a,q) \in I} \\
			      &=& \interpret D t
		      \end{eqnarray*}
		\item $(t = a(t_1,t_2))$\\
		      By induction we know that
		      $\interpret D {t_i} = q_i$ iff there exists a "run" over $t_i$ ending at $q_i$, for $i \in \set {1,2}$.

		      \begin{eqnarray*}
			      q \in \interpret D t &\iff& \delta_a (\interpret D {t_1}, \interpret D {t_2}) \\
			      &\iff& \setdef {q \in  Q} {(x_1,x_2,a,q) \in \Delta, x_1 \in \interpret D {t_1}, x_2 \in \interpret D {t_2}} \\
			      &\iff& \exists x_1,x_2, (x_1,x_2,a,q) \in \Delta, x_1 \in \interpret D {t_1}, x_2 \in \interpret D {t_2} \\
			      &\iff& \text{there exists a "run" over }  t_i  \text { ending at } x_i \text { for  } i \in \set {1,2} \text{ and } (x_1,x_2,a,q) \in \Delta\\
			      &\iff& \exists \exec, \exec (\epsilon) = q
		      \end{eqnarray*}
	\end{itemize}
	Then $ \interpret A t = \setdef {q \in Q} {\exists \exec, \exec (\epsilon) = q} $.

	We must now show that $D$ "accepts" $t$ iff $N$ "accepts" $t$.

	\begin{eqnarray*}
		N \text{ "accepts" } t &\iff& F \cap \setdef {q \in Q} {(a,q) \in I} \neq \emptyset \\
		&\iff&   F \cap  \interpret D t \neq \emptyset \\
		&\iff& \interpret D t  \in F' \\
		&\iff& D \text{ "accepts" } t
	\end{eqnarray*}

	and so $\lang N = \lang D$.

	\todo{Discuss proof}
\end{proof}


\begin{definition}
	We say that a "NBUA" is ""order-insensitive"" if
	\[ \forall p,q,a,r,\, (p,q,a,r) \in \Delta \iff  (q,p,a,r) \in \Delta \]
\end{definition}

\begin{remark}
	For a "DBUA" "order-insensitiveness" is equivalent to
	\[ \forall p,q,a,\, \delta_a (p,q) = \delta_a (q,p) \]
\end{remark}

\begin{lemma}
	If $N$ a "NBUA" is "order-insensitive", then it's corresponding deterministic automaton is also "order-insensitive".
\end{lemma}

\begin{proof}
	Let $D$ be the deterministic automaton corresponding to $N$.
	\begin{eqnarray*}
		\delta_a (X,Y) &=& \setdef {q \in Q} {(x,y,a,q) \in \Delta, x \in X, y \in Y} \\
		&=& \setdef {q \in Q} {(y,x,a,q) \in \Delta, x \in X, y \in Y}  \reason {$N$ is "order-insensitive"} \\
		&=& \delta_a (Y,X)
	\end{eqnarray*}
\end{proof}

\subsection{MSO}

\begin{lemma}
	If $A$ is a "order-insensitive" "NBUA"  then there exists a MSO formula $\phi$ such that for all $t \in \tree_{\Sigma}$,
	\[ M(t) \models \phi \iff t \in \lang A \]
	\todo{Write up all of the missing definitions}
\end{lemma}

\begin{proof}
	Let $A$ be a "NBUA", and $k = \abs Q$.
	\[\text{leaf} (x) = \forall y, \ancestor y x \]
	\[\text{top} (x) = \forall y, \ancestor x y \]
	\[F_i = \setdef {a \in \Sigma} {(i0,i1,a,i) \in \Delta, i \in F}\]


	\begin{eqnarray*}
		\phi = \exists X_0 \ldots \exists X_{k-1} &\ & \forall x \left( \bigvee_{i=0}^{k-1} X_i(x) \right) \\
		&\land& \forall x \left( \text{leaf} (x) \ra \bigvee_{(a,i)\in I}  X_i(x)   \right) \\
		&\land& \forall x \left(\lnot \text{leaf}(x) \ra \bigvee_{(i,j,a,k)\in \Delta}  \left(X_i(x0) \land X_j(x1) \land a(x) \land X_k(x)\right)\right) \\
		&\land& \forall x \left(\text{top}(x) \ra \bigwedge_{i= 0}^k \left( X_i(x) \ra \bigvee_{a \in F_i} a(x) \right)\right)
	\end{eqnarray*}


	\todo {Write actual proof}
\end{proof}



\bibliographystyle{alpha}
\bibliography{tre-uniformisation}

\end{document}
